// Decompiled with JetBrains decompiler
// Type: VERMELHO265MONARCA.Core.Cryptography.Crybra
// Assembly: madre, Version=1.1.2.3, Culture=neutral, PublicKeyToken=null
// MVID: E3E81F5F-5E79-4C7B-AA1D-713B5D376685
// Assembly location: C:\Users\Marcos Abreu\Documents\XPCTRA\idfptray.exe

using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using VERMELHO265MONARCA.Core.Helper;

namespace VERMELHO265MONARCA.Core.Cryptography
{
  public static class Crybra
  {
    public static readonly byte[] FLUENTE35FORRO = new byte[32]
    {
      (byte) 191,
      (byte) 235,
      (byte) 30,
      (byte) 86,
      (byte) 251,
      (byte) 205,
      (byte) 151,
      (byte) 59,
      (byte) 178,
      (byte) 25,
      (byte) 2,
      (byte) 36,
      (byte) 48,
      (byte) 165,
      (byte) 120,
      (byte) 67,
      (byte) 0,
      (byte) 61,
      (byte) 86,
      (byte) 68,
      (byte) 210,
      (byte) 30,
      (byte) 98,
      (byte) 185,
      (byte) 212,
      (byte) 241,
      (byte) 128,
      (byte) 231,
      (byte) 230,
      (byte) 195,
      (byte) 57,
      (byte) 65
    };
    private const int ALFORRIADO742BENEMERITO = 16;
    private const int POCO636PONTILHAO = 32;
    private static byte[] MISTURAR188TENDAO;
    private static byte[] CHAVAO579MEL;

    public static void SetDefaultKey(string key)
    {
      Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(key, Crybra.FLUENTE35FORRO, 50000);
      Crybra.MISTURAR188TENDAO = rfc2898DeriveBytes.GetBytes(16);
      Crybra.CHAVAO579MEL = rfc2898DeriveBytes.GetBytes(64);
    }

    public static void SetDefaultKey(string key, string authKey)
    {
      Crybra.MISTURAR188TENDAO = Convert.FromBase64String(key);
      Crybra.CHAVAO579MEL = Convert.FromBase64String(authKey);
    }

    public static string Encrypt(string input, string key)
    {
      return Convert.ToBase64String(Crybra.Encrypt(Encoding.UTF8.GetBytes(input), Encoding.UTF8.GetBytes(key)));
    }

    public static string Encrypt(string input)
    {
      return Convert.ToBase64String(Crybra.Encrypt(Encoding.UTF8.GetBytes(input)));
    }

    public static byte[] Encrypt(byte[] input)
    {
      if (Crybra.MISTURAR188TENDAO == null || Crybra.MISTURAR188TENDAO.Length == 0)
        throw new Exception("");
      if (input == null || input.Length == 0)
        throw new ArgumentException("");
      byte[] buffer = input;
      byte[] numArray = new byte[0];
      try
      {
        using (MemoryStream memoryStream = new MemoryStream())
        {
          memoryStream.Position = 32L;
          using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
          {
            cryptoServiceProvider.KeySize = 128;
            cryptoServiceProvider.BlockSize = 128;
            cryptoServiceProvider.Mode = CipherMode.CBC;
            cryptoServiceProvider.Padding = PaddingMode.PKCS7;
            cryptoServiceProvider.Key = Crybra.MISTURAR188TENDAO;
            cryptoServiceProvider.GenerateIV();
            using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write))
            {
              memoryStream.Write(cryptoServiceProvider.IV, 0, cryptoServiceProvider.IV.Length);
              cryptoStream.Write(buffer, 0, buffer.Length);
              cryptoStream.FlushFinalBlock();
              using (HMACSHA256 hmacshA256 = new HMACSHA256(Crybra.CHAVAO579MEL))
              {
                byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
                memoryStream.Position = 0L;
                memoryStream.Write(hash, 0, hash.Length);
              }
            }
          }
          numArray = memoryStream.ToArray();
        }
      }
      catch
      {
      }
      return numArray;
    }

    public static byte[] Encrypt(byte[] input, byte[] key)
    {
      if (key == null || key.Length == 0)
        throw new Exception("");
      Rfc2898DeriveBytes rfc2898DeriveBytes = new Rfc2898DeriveBytes(key, Crybra.FLUENTE35FORRO, 50000);
      key = rfc2898DeriveBytes.GetBytes(16);
      byte[] bytes = rfc2898DeriveBytes.GetBytes(64);
      byte[] buffer = input;
      byte[] numArray = new byte[0];
      try
      {
        using (MemoryStream memoryStream = new MemoryStream())
        {
          memoryStream.Position = 32L;
          using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
          {
            cryptoServiceProvider.KeySize = 128;
            cryptoServiceProvider.BlockSize = 128;
            cryptoServiceProvider.Mode = CipherMode.CBC;
            cryptoServiceProvider.Padding = PaddingMode.PKCS7;
            cryptoServiceProvider.Key = key;
            cryptoServiceProvider.GenerateIV();
            using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateEncryptor(), CryptoStreamMode.Write))
            {
              memoryStream.Write(cryptoServiceProvider.IV, 0, cryptoServiceProvider.IV.Length);
              cryptoStream.Write(buffer, 0, buffer.Length);
              cryptoStream.FlushFinalBlock();
              using (HMACSHA256 hmacshA256 = new HMACSHA256(bytes))
              {
                byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
                memoryStream.Position = 0L;
                memoryStream.Write(hash, 0, hash.Length);
              }
            }
          }
          numArray = memoryStream.ToArray();
        }
      }
      catch
      {
      }
      return numArray;
    }

    public static string Decrypt(string input)
    {
      return Encoding.UTF8.GetString(Crybra.Decrypt(Convert.FromBase64String(input)));
    }

    public static byte[] Decrypt(byte[] input)
    {
      if (Crybra.MISTURAR188TENDAO == null || Crybra.MISTURAR188TENDAO.Length == 0)
        throw new Exception("");
      if (input == null || input.Length == 0)
        throw new ArgumentException("");
      byte[] numArray1 = new byte[0];
      try
      {
        using (MemoryStream memoryStream = new MemoryStream(input))
        {
          using (AesCryptoServiceProvider cryptoServiceProvider = new AesCryptoServiceProvider())
          {
            cryptoServiceProvider.KeySize = 128;
            cryptoServiceProvider.BlockSize = 128;
            cryptoServiceProvider.Mode = CipherMode.CBC;
            cryptoServiceProvider.Padding = PaddingMode.PKCS7;
            cryptoServiceProvider.Key = Crybra.MISTURAR188TENDAO;
            using (HMACSHA256 hmacshA256 = new HMACSHA256(Crybra.CHAVAO579MEL))
            {
              byte[] hash = hmacshA256.ComputeHash(memoryStream.ToArray(), 32, memoryStream.ToArray().Length - 32);
              byte[] numArray2 = new byte[32];
              memoryStream.Read(numArray2, 0, numArray2.Length);
              if (!CENSURADO30CARAPUCA.AreEqual(hash, numArray2))
                return numArray1;
            }
            byte[] buffer1 = new byte[16];
            memoryStream.Read(buffer1, 0, 16);
            cryptoServiceProvider.IV = buffer1;
            using (CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, cryptoServiceProvider.CreateDecryptor(), CryptoStreamMode.Read))
            {
              byte[] buffer2 = new byte[memoryStream.Length - 16L + 1L];
              numArray1 = new byte[cryptoStream.Read(buffer2, 0, buffer2.Length)];
              Buffer.BlockCopy((Array) buffer2, 0, (Array) numArray1, 0, numArray1.Length);
            }
          }
        }
      }
      catch
      {
      }
      return numArray1;
    }
  }
}
