// Decompiled with JetBrains decompiler
// Type: VERMELHO265MONARCA.Core.NetSerializer.CodeGenContext
// Assembly: madre, Version=1.1.2.3, Culture=neutral, PublicKeyToken=null
// MVID: E3E81F5F-5E79-4C7B-AA1D-713B5D376685
// Assembly location: C:\Users\Marcos Abreu\Documents\XPCTRA\idfptray.exe

using System;
using System.Collections.Generic;
using System.Reflection;

namespace VERMELHO265MONARCA.Core.NetSerializer
{
  public sealed class CodeGenContext
  {
    private readonly Dictionary<Type, TypeData> m_typeMap;

    public CodeGenContext(Dictionary<Type, TypeData> typeMap)
    {
      this.m_typeMap = typeMap;
      TypeData type = this.m_typeMap[typeof (object)];
      this.SerializerSwitchMethodInfo = type.WriterMethodInfo;
      this.DeserializerSwitchMethodInfo = type.ReaderMethodInfo;
    }

    public MethodInfo SerializerSwitchMethodInfo { get; private set; }

    public MethodInfo DeserializerSwitchMethodInfo { get; private set; }

    public MethodInfo GetWriterMethodInfo(Type type)
    {
      return this.m_typeMap[type].WriterMethodInfo;
    }

    public MethodInfo GetReaderMethodInfo(Type type)
    {
      return this.m_typeMap[type].ReaderMethodInfo;
    }

    public bool IsGenerated(Type type)
    {
      return this.m_typeMap[type].IsGenerated;
    }

    public IDictionary<Type, TypeData> TypeMap
    {
      get
      {
        return (IDictionary<Type, TypeData>) this.m_typeMap;
      }
    }

    private bool CanCallDirect(Type type)
    {
      return type.IsValueType || type.IsArray || type.IsSealed && !this.IsGenerated(type);
    }

    public TypeData GetTypeData(Type type)
    {
      return this.m_typeMap[type];
    }

    public TypeData GetTypeDataForCall(Type type)
    {
      if (!this.CanCallDirect(type))
        type = typeof (object);
      return this.GetTypeData(type);
    }
  }
}
