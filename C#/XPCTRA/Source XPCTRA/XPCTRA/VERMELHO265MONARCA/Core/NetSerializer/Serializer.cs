// Decompiled with JetBrains decompiler
// Type: VERMELHO265MONARCA.Core.NetSerializer.Serializer
// Assembly: madre, Version=1.1.2.3, Culture=neutral, PublicKeyToken=null
// MVID: E3E81F5F-5E79-4C7B-AA1D-713B5D376685
// Assembly location: C:\Users\Marcos Abreu\Documents\XPCTRA\idfptray.exe

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Reflection.Emit;
using VERMELHO265MONARCA.Core.NetSerializer.TypeSerializers;

namespace VERMELHO265MONARCA.Core.NetSerializer
{
  public class Serializer
  {
    private static ITypeSerializer[] s_typeSerializers = new ITypeSerializer[6]
    {
      (ITypeSerializer) new ObjectSerializer(),
      (ITypeSerializer) new ALAMBRE980LIDASerializer(),
      (ITypeSerializer) new ArraySerializer(),
      (ITypeSerializer) new EnumSerializer(),
      (ITypeSerializer) new DictionarySerializer(),
      (ITypeSerializer) new GenericSerializer()
    };
    private Dictionary<Type, ushort> m_typeIDMap;
    private Serializer.SerializerSwitch m_serializerSwitch;
    private Serializer.DeserializerSwitch m_deserializerSwitch;
    private ITypeSerializer[] m_userTypeSerializers;

    public Serializer(IEnumerable<Type> rootTypes)
      : this(rootTypes, new ITypeSerializer[0])
    {
    }

    public Serializer(IEnumerable<Type> rootTypes, ITypeSerializer[] userTypeSerializers)
    {
      ITypeSerializer[] typeSerializerArray = userTypeSerializers;
      Func<ITypeSerializer, bool> func1 = (Func<ITypeSerializer, bool>) (s =>
      {
        if (!(s is IDynamicTypeSerializer))
          return s is IStaticTypeSerializer;
        return true;
      });
      Func<ITypeSerializer, bool> predicate;
      if (!((IEnumerable<ITypeSerializer>) typeSerializerArray).All<ITypeSerializer>(predicate))
        throw new ArgumentException("TypeSerializers have to implement IDynamicTypeSerializer or  IStaticTypeSerializer");
      this.m_userTypeSerializers = userTypeSerializers;
      Dictionary<Type, TypeData> typeData = this.GenerateTypeData(rootTypes);
      this.GenerateDynamic(typeData);
      Dictionary<Type, TypeData> source = typeData;
      Func<KeyValuePair<Type, TypeData>, Type> func2 = (Func<KeyValuePair<Type, TypeData>, Type>) (kvp => kvp.Key);
      Func<KeyValuePair<Type, TypeData>, Type> keySelector;
      this.m_typeIDMap = source.ToDictionary<KeyValuePair<Type, TypeData>, Type, ushort>(keySelector, (Func<KeyValuePair<Type, TypeData>, ushort>) (kvp => kvp.Value.TypeID));
    }

    public void Serialize(Stream stream, object data)
    {
      this.m_serializerSwitch(this, stream, data);
    }

    public object Deserialize(Stream stream)
    {
      object ob;
      this.m_deserializerSwitch(this, stream, out ob);
      return ob;
    }

    private Dictionary<Type, TypeData> GenerateTypeData(IEnumerable<Type> rootTypes)
    {
      Dictionary<Type, TypeData> dictionary = new Dictionary<Type, TypeData>();
      Stack<Type> typeStack = new Stack<Type>(ALAMBRE980LIDASerializer.GetSupportedTypes().Concat<Type>(rootTypes));
      typeStack.Push(typeof (object));
      ushort num = 1;
      while (typeStack.Count > 0)
      {
        Type type = typeStack.Pop();
        if (!dictionary.ContainsKey(type) && (!type.IsAbstract && !type.IsInterface))
        {
          if (type.ContainsGenericParameters)
            throw new NotSupportedException(string.Format("Type {0} contains generic parameters", (object) type.FullName));
          ITypeSerializer typeSerializer = ((IEnumerable<ITypeSerializer>) this.m_userTypeSerializers).FirstOrDefault<ITypeSerializer>((Func<ITypeSerializer, bool>) (h => h.Handles(type))) ?? ((IEnumerable<ITypeSerializer>) Serializer.s_typeSerializers).FirstOrDefault<ITypeSerializer>((Func<ITypeSerializer, bool>) (h => h.Handles(type)));
          if (typeSerializer == null)
            throw new NotSupportedException(string.Format("No serializer for {0}", (object) type.FullName));
          foreach (Type subtype in typeSerializer.GetSubtypes(type))
            typeStack.Push(subtype);
          TypeData typeData;
          if (typeSerializer is IStaticTypeSerializer)
          {
            MethodInfo writer;
            MethodInfo reader;
            ((IStaticTypeSerializer) typeSerializer).GetStaticMethods(type, out writer, out reader);
            Debug.Assert(writer != null && reader != null);
            typeData = new TypeData(num++, writer, reader);
          }
          else
          {
            if (!(typeSerializer is IDynamicTypeSerializer))
              throw new Exception();
            IDynamicTypeSerializer serializer = (IDynamicTypeSerializer) typeSerializer;
            typeData = new TypeData(num++, serializer);
          }
          dictionary[type] = typeData;
        }
      }
      return dictionary;
    }

    private void GenerateDynamic(Dictionary<Type, TypeData> map)
    {
      foreach (KeyValuePair<Type, TypeData> keyValuePair in map)
      {
        Type key = keyValuePair.Key;
        TypeData typeData = keyValuePair.Value;
        if (typeData.IsGenerated)
        {
          typeData.WriterMethodInfo = (MethodInfo) Helpers.GenerateDynamicSerializerStub(key);
          typeData.ReaderMethodInfo = (MethodInfo) Helpers.GenerateDynamicDeserializerStub(key);
        }
      }
      CodeGenContext ctx = new CodeGenContext(map);
      foreach (KeyValuePair<Type, TypeData> keyValuePair in map)
      {
        Type key = keyValuePair.Key;
        TypeData typeData = keyValuePair.Value;
        if (typeData.IsGenerated)
        {
          DynamicMethod writerMethodInfo = (DynamicMethod) typeData.WriterMethodInfo;
          typeData.TypeSerializer.GenerateWriterMethod(key, ctx, writerMethodInfo.GetILGenerator());
          DynamicMethod readerMethodInfo = (DynamicMethod) typeData.ReaderMethodInfo;
          typeData.TypeSerializer.GenerateReaderMethod(key, ctx, readerMethodInfo.GetILGenerator());
        }
      }
      DynamicMethod writerMethodInfo1 = (DynamicMethod) ctx.GetWriterMethodInfo(typeof (object));
      DynamicMethod readerMethodInfo1 = (DynamicMethod) ctx.GetReaderMethodInfo(typeof (object));
      this.m_serializerSwitch = (Serializer.SerializerSwitch) writerMethodInfo1.CreateDelegate(typeof (Serializer.SerializerSwitch));
      this.m_deserializerSwitch = (Serializer.DeserializerSwitch) readerMethodInfo1.CreateDelegate(typeof (Serializer.DeserializerSwitch));
    }

    private ushort GetTypeID(object ob)
    {
      if (ob == null)
        return 0;
      Type type = ob.GetType();
      ushort num;
      if (!this.m_typeIDMap.TryGetValue(type, out num))
        throw new InvalidOperationException(string.Format("Unknown type {0}", (object) type.FullName));
      return num;
    }

    private delegate void SerializerSwitch(Serializer serializer, Stream stream, object ob);

    private delegate void DeserializerSwitch(Serializer serializer, Stream stream, out object ob);
  }
}
