// Decompiled with JetBrains decompiler
// Type: VERMELHO265MONARCA.Core.Utilities.HostsManager
// Assembly: madre, Version=1.1.2.3, Culture=neutral, PublicKeyToken=null
// MVID: E3E81F5F-5E79-4C7B-AA1D-713B5D376685
// Assembly location: C:\Users\Marcos Abreu\Documents\XPCTRA\idfptray.exe

using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using VERMELHO265MONARCA.Core.Data;

namespace VERMELHO265MONARCA.Core.Utilities
{
  public class HostsManager
  {
    private readonly Queue<Host> _hosts = new Queue<Host>();

    public bool IsEmpty
    {
      get
      {
        return this._hosts.Count == 0;
      }
    }

    public HostsManager(List<Host> hosts)
    {
      foreach (Host host in hosts)
        this._hosts.Enqueue(host);
    }

    public Host GetNextHost()
    {
      Host host = this._hosts.Dequeue();
      this._hosts.Enqueue(host);
      host.IpAddress = HostsManager.GetIp(host);
      return host;
    }

    private static IPAddress GetIp(Host host)
    {
      if (string.IsNullOrEmpty(host.Hostname))
        return (IPAddress) null;
      IPAddress address;
      if (IPAddress.TryParse(host.Hostname, out address))
      {
        if (address.AddressFamily == AddressFamily.InterNetworkV6 && !Socket.OSSupportsIPv6)
          return (IPAddress) null;
        return address;
      }
      IPAddress[] addressList = Dns.GetHostEntry(host.Hostname).AddressList;
      foreach (IPAddress ipAddress in addressList)
      {
        switch (ipAddress.AddressFamily)
        {
          case AddressFamily.InterNetwork:
            return ipAddress;
          case AddressFamily.InterNetworkV6:
            if (addressList.Length == 1)
              return ipAddress;
            break;
        }
      }
      return address;
    }
  }
}
