// Decompiled with JetBrains decompiler
// Type: VERMELHO265MONARCA.Core.Compression.SafeQuickLZ
// Assembly: madre, Version=1.1.2.3, Culture=neutral, PublicKeyToken=null
// MVID: E3E81F5F-5E79-4C7B-AA1D-713B5D376685
// Assembly location: C:\Users\Marcos Abreu\Documents\XPCTRA\idfptray.exe

using System;

namespace VERMELHO265MONARCA.Core.Compression
{
  public static class SafeQuickLZ
  {
    public const int QLZ_VERSION_MAJOR = 1;
    public const int QLZ_VERSION_MINOR = 5;
    public const int QLZ_VERSION_REVISION = 0;
    public const int QLZ_STREAMING_BUFFER = 0;
    public const int QLZ_MEMORY_SAFE = 0;
    private const int HASH_VALUES = 4096;
    private const int MINOFFSET = 2;
    private const int UNCONDITIONAL_MATCHLEN = 6;
    private const int UNCOMPRESSED_END = 4;
    private const int CWORD_LEN = 4;
    private const int DEFAULT_HEADERLEN = 9;
    private const int QLZ_POINTERS_1 = 1;
    private const int QLZ_POINTERS_3 = 16;

    private static int HeaderLength(byte[] source)
    {
      return ((int) source[0] & 2) == 2 ? 9 : 3;
    }

    public static int SizeDecompressed(byte[] source)
    {
      if (SafeQuickLZ.HeaderLength(source) == 9)
        return (int) source[5] | (int) source[6] << 8 | (int) source[7] << 16 | (int) source[8] << 24;
      return (int) source[2];
    }

    public static int SizeCompressed(byte[] source)
    {
      if (SafeQuickLZ.HeaderLength(source) == 9)
        return (int) source[1] | (int) source[2] << 8 | (int) source[3] << 16 | (int) source[4] << 24;
      return (int) source[1];
    }

    private static void WriteHeader(byte[] dst, int level, bool compressible, int sizeCompressed, int sizeDecompressed)
    {
      dst[0] = (byte) (2 | (compressible ? 1 : 0));
      dst[0] |= (byte) (level << 2);
      dst[0] |= (byte) 64;
      dst[0] |= (byte) 0;
      SafeQuickLZ.FastWrite(dst, 1, sizeDecompressed, 4);
      SafeQuickLZ.FastWrite(dst, 5, sizeCompressed, 4);
    }

    public static byte[] Compress(byte[] source, int level = 3)
    {
      if (source.Length == 0)
        return new byte[0];
      int[,] numArray1;
      switch (level)
      {
        case 1:
          numArray1 = new int[4096, 1];
          break;
        case 3:
          numArray1 = new int[4096, 16];
          break;
        default:
          throw new ArgumentException("C# version only supports level 1 and 3");
      }
      int index1 = 0;
      int length = 13;
      uint num1 = 2147483648;
      int i = 9;
      byte[] numArray2 = new byte[source.Length + 400];
      int[] numArray3 = new int[4096];
      byte[] numArray4 = new byte[4096];
      int num2 = 0;
      int num3 = source.Length - 6 - 4 - 1;
      int num4 = 0;
      if (index1 <= num3)
        num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
      while (index1 <= num3)
      {
        if (((int) num1 & 1) == 1)
        {
          if (index1 > source.Length >> 1 && length > index1 - (index1 >> 5))
          {
            byte[] dst = new byte[source.Length + 9];
            SafeQuickLZ.WriteHeader(dst, level, false, source.Length, source.Length + 9);
            Array.Copy((Array) source, 0, (Array) dst, 9, source.Length);
            return dst;
          }
          SafeQuickLZ.FastWrite(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
          i = length;
          length += 4;
          num1 = 2147483648U;
        }
        if (level == 1)
        {
          int index2 = (num2 >> 12 ^ num2) & 4095;
          int num5 = numArray1[index2, 0];
          int num6 = numArray3[index2] ^ num2;
          numArray3[index2] = num2;
          numArray1[index2, 0] = index1;
          if (num6 == 0 && (int) numArray4[index2] != 0 && (index1 - num5 > 2 || index1 == num5 + 1 && num4 >= 3 && (index1 > 3 && (int) source[index1] == (int) source[index1 - 3]) && ((int) source[index1] == (int) source[index1 - 2] && (int) source[index1] == (int) source[index1 - 1] && (int) source[index1] == (int) source[index1 + 1]) && (int) source[index1] == (int) source[index1 + 2]))
          {
            num1 = num1 >> 1 | 2147483648U;
            if ((int) source[num5 + 3] != (int) source[index1 + 3])
            {
              int num7 = 1 | index2 << 4;
              numArray2[length + 0] = (byte) num7;
              numArray2[length + 1] = (byte) (num7 >> 8);
              index1 += 3;
              length += 2;
            }
            else
            {
              int num7 = index1;
              int num8 = source.Length - 4 - index1 + 1 - 1 > (int) byte.MaxValue ? (int) byte.MaxValue : source.Length - 4 - index1 + 1 - 1;
              index1 += 4;
              if ((int) source[num5 + index1 - num7] == (int) source[index1])
              {
                ++index1;
                if ((int) source[num5 + index1 - num7] == (int) source[index1])
                {
                  ++index1;
                  while ((int) source[num5 + (index1 - num7)] == (int) source[index1] && index1 - num7 < num8)
                    ++index1;
                }
              }
              int num9 = index1 - num7;
              int num10 = index2 << 4;
              if (num9 < 18)
              {
                int num11 = num10 | num9 - 2;
                numArray2[length + 0] = (byte) num11;
                numArray2[length + 1] = (byte) (num11 >> 8);
                length += 2;
              }
              else
              {
                SafeQuickLZ.FastWrite(numArray2, length, num10 | num9 << 16, 3);
                length += 3;
              }
            }
            num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
            num4 = 0;
          }
          else
          {
            ++num4;
            numArray4[index2] = (byte) 1;
            numArray2[length] = source[index1];
            num1 >>= 1;
            ++index1;
            ++length;
            num2 = num2 >> 8 & (int) ushort.MaxValue | (int) source[index1 + 2] << 16;
          }
        }
        else
        {
          num2 = (int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16;
          int num5 = 0;
          int num6 = source.Length - 4 - index1 + 1 - 1 > (int) byte.MaxValue ? (int) byte.MaxValue : source.Length - 4 - index1 + 1 - 1;
          int index2 = (num2 >> 12 ^ num2) & 4095;
          byte num7 = numArray4[index2];
          int num8 = 0;
          int num9 = 0;
          for (int index3 = 0; index3 < 16 && (int) num7 > index3; ++index3)
          {
            int index4 = numArray1[index2, index3];
            if ((int) (byte) num2 == (int) source[index4] && (int) (byte) (num2 >> 8) == (int) source[index4 + 1] && (int) (byte) (num2 >> 16) == (int) source[index4 + 2] && index4 < index1 - 2)
            {
              int num10 = 3;
              while ((int) source[index4 + num10] == (int) source[index1 + num10] && num10 < num6)
                ++num10;
              if (num10 > num8 || num10 == num8 && index4 > num9)
              {
                num9 = index4;
                num8 = num10;
                num5 = index3;
              }
            }
          }
          int num11 = num9;
          numArray1[index2, (int) num7 & 15] = index1;
          byte num12 = (byte) ((uint) num7 + 1U);
          numArray4[index2] = num12;
          if (num8 >= 3 && index1 - num11 < 131071)
          {
            int num10 = index1 - num11;
            for (int index3 = 1; index3 < num8; ++index3)
            {
              num2 = (int) source[index1 + index3] | (int) source[index1 + index3 + 1] << 8 | (int) source[index1 + index3 + 2] << 16;
              int index4 = (num2 >> 12 ^ num2) & 4095;
              byte num13 = numArray4[index4]++;
              numArray1[index4, (int) num13 & 15] = index1 + index3;
            }
            index1 += num8;
            num1 = num1 >> 1 | 2147483648U;
            if (num8 == 3 && num10 <= 63)
            {
              SafeQuickLZ.FastWrite(numArray2, length, num10 << 2, 1);
              ++length;
            }
            else if (num8 == 3 && num10 <= 16383)
            {
              SafeQuickLZ.FastWrite(numArray2, length, num10 << 2 | 1, 2);
              length += 2;
            }
            else if (num8 <= 18 && num10 <= 1023)
            {
              SafeQuickLZ.FastWrite(numArray2, length, num8 - 3 << 2 | num10 << 6 | 2, 2);
              length += 2;
            }
            else if (num8 <= 33)
            {
              SafeQuickLZ.FastWrite(numArray2, length, num8 - 2 << 2 | num10 << 7 | 3, 3);
              length += 3;
            }
            else
            {
              SafeQuickLZ.FastWrite(numArray2, length, num8 - 3 << 7 | num10 << 15 | 3, 4);
              length += 4;
            }
            num4 = 0;
          }
          else
          {
            numArray2[length] = source[index1];
            num1 >>= 1;
            ++index1;
            ++length;
          }
        }
      }
      while (index1 <= source.Length - 1)
      {
        if (((int) num1 & 1) == 1)
        {
          SafeQuickLZ.FastWrite(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
          i = length;
          length += 4;
          num1 = 2147483648U;
        }
        numArray2[length] = source[index1];
        ++index1;
        ++length;
        num1 >>= 1;
      }
      while (((int) num1 & 1) != 1)
        num1 >>= 1;
      SafeQuickLZ.FastWrite(numArray2, i, (int) (num1 >> 1) | int.MinValue, 4);
      SafeQuickLZ.WriteHeader(numArray2, level, true, source.Length, length);
      byte[] numArray5 = new byte[length];
      Array.Copy((Array) numArray2, (Array) numArray5, length);
      return numArray5;
    }

    private static void FastWrite(byte[] a, int i, int value, int numbytes)
    {
      for (int index = 0; index < numbytes; ++index)
        a[i + index] = (byte) (value >> index * 8);
    }

    public static byte[] Decompress(byte[] source)
    {
      if (source.Length == 0)
        return new byte[0];
      int num1 = (int) source[0] >> 2 & 3;
      if (num1 != 1 && num1 != 3)
        throw new ArgumentException("C# version only supports level 1 and 3");
      int length = SafeQuickLZ.SizeDecompressed(source);
      int index1 = SafeQuickLZ.HeaderLength(source);
      int index2 = 0;
      uint num2 = 1;
      byte[] numArray1 = new byte[length];
      int[] numArray2 = new int[4096];
      byte[] numArray3 = new byte[4096];
      int num3 = length - 6 - 4 - 1;
      int index3 = -1;
      uint num4 = 0;
      if (((int) source[0] & 1) != 1)
      {
        byte[] numArray4 = new byte[length];
        Array.Copy((Array) source, SafeQuickLZ.HeaderLength(source), (Array) numArray4, 0, length);
        return numArray4;
      }
      while (true)
      {
        if ((int) num2 == 1)
        {
          num2 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
          index1 += 4;
          if (index2 <= num3)
            num4 = num1 != 1 ? (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24) : (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
        }
        if (((int) num2 & 1) == 1)
        {
          num2 >>= 1;
          uint num5;
          uint num6;
          if (num1 == 1)
          {
            int index4 = (int) num4 >> 4 & 4095;
            num5 = (uint) numArray2[index4];
            if ((num4 & 15U) > 0U)
            {
              num6 = (uint) (((int) num4 & 15) + 2);
              index1 += 2;
            }
            else
            {
              num6 = (uint) source[index1 + 2];
              index1 += 3;
            }
          }
          else
          {
            uint num7;
            if (((int) num4 & 3) == 0)
            {
              num7 = (num4 & (uint) byte.MaxValue) >> 2;
              num6 = 3U;
              ++index1;
            }
            else if (((int) num4 & 2) == 0)
            {
              num7 = (num4 & (uint) ushort.MaxValue) >> 2;
              num6 = 3U;
              index1 += 2;
            }
            else if (((int) num4 & 1) == 0)
            {
              num7 = (num4 & (uint) ushort.MaxValue) >> 6;
              num6 = (uint) (((int) (num4 >> 2) & 15) + 3);
              index1 += 2;
            }
            else if (((int) num4 & (int) sbyte.MaxValue) != 3)
            {
              num7 = num4 >> 7 & 131071U;
              num6 = (uint) (((int) (num4 >> 2) & 31) + 2);
              index1 += 3;
            }
            else
            {
              num7 = num4 >> 15;
              num6 = (uint) (((int) (num4 >> 7) & (int) byte.MaxValue) + 3);
              index1 += 4;
            }
            num5 = (uint) ((ulong) index2 - (ulong) num7);
          }
          numArray1[index2 + 0] = numArray1[(int) num5 + 0];
          numArray1[index2 + 1] = numArray1[(int) num5 + 1];
          numArray1[index2 + 2] = numArray1[(int) num5 + 2];
          for (int index4 = 3; (long) index4 < (long) num6; ++index4)
            numArray1[index2 + index4] = numArray1[(long) num5 + (long) index4];
          index2 += (int) num6;
          if (num1 == 1)
          {
            uint num7 = (uint) ((int) numArray1[index3 + 1] | (int) numArray1[index3 + 2] << 8 | (int) numArray1[index3 + 3] << 16);
            while ((long) index3 < (long) index2 - (long) num6)
            {
              ++index3;
              int index4 = ((int) (num7 >> 12) ^ (int) num7) & 4095;
              numArray2[index4] = index3;
              numArray3[index4] = (byte) 1;
              num7 = (uint) ((ulong) (num7 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) numArray1[index3 + 3] << 16));
            }
            num4 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16);
          }
          else
            num4 = (uint) ((int) source[index1] | (int) source[index1 + 1] << 8 | (int) source[index1 + 2] << 16 | (int) source[index1 + 3] << 24);
          index3 = index2 - 1;
        }
        else if (index2 <= num3)
        {
          numArray1[index2] = source[index1];
          ++index2;
          ++index1;
          num2 >>= 1;
          if (num1 == 1)
          {
            while (index3 < index2 - 3)
            {
              ++index3;
              int num5 = (int) numArray1[index3] | (int) numArray1[index3 + 1] << 8 | (int) numArray1[index3 + 2] << 16;
              int index4 = (num5 >> 12 ^ num5) & 4095;
              numArray2[index4] = index3;
              numArray3[index4] = (byte) 1;
            }
            num4 = (uint) ((ulong) (num4 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16));
          }
          else
            num4 = (uint) ((ulong) (num4 >> 8 & (uint) ushort.MaxValue) | (ulong) ((int) source[index1 + 2] << 16) | (ulong) ((int) source[index1 + 3] << 24));
        }
        else
          break;
      }
      while (index2 <= length - 1)
      {
        if ((int) num2 == 1)
        {
          index1 += 4;
          num2 = 2147483648U;
        }
        numArray1[index2] = source[index1];
        ++index2;
        ++index1;
        num2 >>= 1;
      }
      return numArray1;
    }
  }
}
