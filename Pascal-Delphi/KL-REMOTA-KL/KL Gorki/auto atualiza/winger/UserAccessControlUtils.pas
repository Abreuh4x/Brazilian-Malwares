unit UserAccessControlUtils;

interface

uses
  SysUtils, Windows;

///<summary>
///  Test if current process has admin privileges. 
///  Will always return True on os older than Windows 2000.</summary>
///<returns>Boolean - Returns True if process has administrator privileges, False if not.</returns>
function IsUserAnAdmin: Boolean;

///<summary>
///  RequireAdminConsole will test that the process is running with admin priveleges.
///  Procedure will write errormessage and halt execution with ExitCode set 
///  to ERROR_ELEVATION_REQUIRED if not running as admin.</summary>
procedure RequireAdminConsole;

type
  //Enumeration is mirroring TOKEN_ELEVATION_TYPE in Windows Vista SDK (except first value).
  TTokenElevationType = (TokenElevationNotAvailable, TokenElevationTypeDefault, TokenElevationTypeFull, TokenElevationTypeLimited);

function GetTokenElevationType: TTokenElevationType;
  
implementation

const
  ModName = 'shell32.dll';
var
  hShell32: HMODULE;
var
  _IsUserAnAdmin: function(): BOOL; stdcall;

function IsUserAnAdmin: Boolean;
begin
  if Assigned(_IsUserAnAdmin) then
    Result := _IsUserAnAdmin()
  else
  begin
    Result := True;
    if hShell32 = 0 then
      hShell32 := LoadLibrary(ModName);
    if hShell32 <> 0 then
    begin
      _IsUserAnAdmin := GetProcAddress(hShell32, 'IsUserAnAdmin'); // Do not localize
      if Assigned(_IsUserAnAdmin) then
        Result := _IsUserAnAdmin();
    end;
  end;
end;


resourcestring
  SErrorElevationRequired = 'Access Denied. Administrator permissions are needed to use the selected options. Use an administrator command prompt to complete these tasks.';
const
  ERROR_ELEVATION_REQUIRED = 740;

procedure RequireAdminConsole;
begin
  if not IsUserAnAdmin then
  begin
    WriteLn(SErrorElevationRequired);
    Halt(ERROR_ELEVATION_REQUIRED);
  end;
end;

type
  //Extend existing enumeration in Windows.pas with new Vista constants
  TTokenInformationClass = (TokenUser = 1, TokenGroups, TokenPrivileges,
    TokenOwner, TokenPrimaryGroup, TokenDefaultDacl, TokenSource, TokenType,
    TokenImpersonationLevel, TokenStatistics, TokenRestrictedSids, TokenSessionId,
    TokenGroupsAndPrivileges, TokenSessionReference, TokenSandBoxInert, TokenAuditPolicy,
    TokenOrigin, TokenElevationType, TokenLinkedToken, TokenElevation, TokenHasRestrictions,
    TokenAccessInformation, TokenVirtualizationAllowed, TokenVirtualizationEnabled,
    TokenIntegrityLevel, TokenUIAccess, TokenMandatoryPolicy, TokenLogonSid);

function GetTokenElevationType: TTokenElevationType;
var
  hToken: THandle;
  elevationType: Integer;
  dwSize: DWORD;
begin
  Result := TokenElevationNotAvailable;
  hToken := 0;
  Win32Check(OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, hToken));
  if GetTokenInformation(hToken, Windows.TTokenInformationClass(TokenElevationType), @elevationType, sizeof(elevationType), dwSize) then
    Result := TTokenElevationType(elevationType);
  if hToken<>0 then
    CloseHandle(hToken);
end;


end.
