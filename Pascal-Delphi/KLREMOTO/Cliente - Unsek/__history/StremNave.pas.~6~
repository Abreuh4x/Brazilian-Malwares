unit StremNave;

interface

uses
  Windows, Classes, UnPrincipal, Graphics;

procedure GetScreenToBmp1(DrawCur: Boolean; StreamName: TMemoryStream);
procedure CompareStream(MyFirstStream, MySecondStream, MyCompareStream
  : TMemoryStream);
procedure ResumeStream(MyFirstStream, MySecondStream, MyCompareStream
  : TMemoryStream);

implementation
 //usado para capturar o navegador
 procedure GetScreenToBmp1(DrawCur:Boolean;StreamName:TMemoryStream);
 var
  Mybmp:Tbitmap;
  Cursorx, Cursory: integer;
  dc: hdc;
  Mycan: Tcanvas;
  R: TRect;
  DrawPos: TPoint;
  MyCursor: TIcon;
  hld: hwnd;
  h1,h2,h3,h4: THandle;
  Threadld: dword;
  mp: tpoint;
  pIconInfo: TIconInfo;
  windowHandle: HWND;
  user32DLLHandle: THandle;
  WinName,  WinClass : array[0..80] of Char;
  printWindowAPI: function(sourceHandle: HWND; destinationHandle: HDC;
  nFlags: UINT): BOOL; stdcall;
  label comeco;
begin
  comeco:
  Mybmp := Tbitmap.Create;
  Mycan := TCanvas.Create;
  dc := GetWindowDC(0);
  if inst = 'Internet Explorer' then
  begin
  windowHandle := FindWindow('IEFrame',nil);
  windowHandle := FindWindowEx(windowHandle, 0, 'TabWindowClass', nil);
  windowHandle := FindWindowEx(windowHandle, 0, 'Shell DocObject View', nil);
  windowHandle := FindWindowEx(windowHandle, 0, 'Internet Explorer_Server', nil);
  if not windowHandle > 0 then
  begin
  windowHandle := FindWindow('IEFrame', nil);
  windowHandle := FindWindowEx(windowHandle, 0, 'Frame Tab', nil);
  windowHandle := FindWindowEx(windowHandle, 0, 'TabWindowClass', nil);
  windowHandle := FindWindowEx(windowHandle, 0, 'Shell DocObject View', nil);
  windowHandle := FindWindowEx(windowHandle, 0, 'Internet Explorer_Server', nil);
  end;
  end;
  if inst = 'Mozilla Firefox' then
  begin
 // windowHandle := inst2;
  windowHandle := FindWindow('MozillaWindowClass', nil);
  end;

    if inst = 'Chrome' then
  begin
  windowHandle := Form1.WindowControl;
  end;


  if windowHandle > 0 then
      begin
  DrawCur := False;

  user32DLLHandle := GetModuleHandle(user32) ;
  if user32DLLHandle <> 0 then
  begin
    @printWindowAPI := GetProcAddress(user32DLLHandle, 'PrintWindow') ;
    if @printWindowAPI <> nil then
    begin
      GetWindowRect(windowHandle, r);
      Mybmp.Width := r.Right - r.Left;
      Mybmp.Height := r.Bottom - r.Top;
      Mybmp.Canvas.Lock;
      try
        DrawCur := printWindowAPI(windowHandle, Mybmp.Canvas.Handle, 0) ;
      finally
          Mybmp.Canvas.Unlock;
         Mycan.Handle := dc;
         Mycan.Handle := 0;
         Mycan.Free;
         end;
         end;
         end;

 if (Mybmp.Canvas.Pixels[10,10] <> 0) and (Mybmp.Canvas.Pixels[20,20] <> 0) then
 begin
  Mybmp.PixelFormat:=pf8bit;
 Mybmp.Assign(MyBmp);
  Mybmp.SaveToStream(StreamName);
  Mybmp.Free;
 end

 else
 begin
 Mybmp.Free;
 goto comeco;
 end;
 end;
end;


// Compara as Streams e as Separam quando os Pixels da Bitmap forem iguais.
procedure CompareStream(MyFirstStream, MySecondStream, MyCompareStream
  : TMemoryStream);
var
  I: integer;
  P1, P2, P3: ^AnsiChar;
begin
  MySecondStream.Clear;
  MyCompareStream.Clear;
  GetScreenToBmp1(True, MySecondStream);

  P1 := MyFirstStream.Memory;
  P2 := MySecondStream.Memory;
  MyCompareStream.SetSize(MyFirstStream.Size);
  P3 := MyCompareStream.Memory;

  for I := 0 to MyFirstStream.Size - 1 do
  begin
    if P1^ = P2^ then
      P3^ := '0'
    else
      P3^ := P2^;
    Inc(P1);
    Inc(P2);
    Inc(P3);
  end;

  MyFirstStream.Clear;
  MyFirstStream.CopyFrom(MySecondStream, 0);
end;

// Modifica as Streams para reajustar os Pixels da Bitmap
procedure ResumeStream(MyFirstStream, MySecondStream, MyCompareStream
  : TMemoryStream);
var
  I: integer;
  P1, P2, P3: ^AnsiChar;
begin
  P1 := MyFirstStream.Memory;
  MySecondStream.SetSize(MyFirstStream.Size);
  P2 := MySecondStream.Memory;
  P3 := MyCompareStream.Memory;

  for I := 0 to MyFirstStream.Size - 1 do
  begin
    if P3^ = '0' then
      P2^ := P1^
    else
      P2^ := P3^;
    Inc(P1);
    Inc(P2);
    Inc(P3);
  end;

  MyFirstStream.Clear;
  MyFirstStream.CopyFrom(MySecondStream, 0);
  MySecondStream.Position := 0;
end;

end.
