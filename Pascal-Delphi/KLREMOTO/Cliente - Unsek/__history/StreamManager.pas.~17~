unit StreamManager;

interface

uses
Windows, Forms, Classes,  Graphics, jpeg;


procedure GetScreenToBmp(DrawCur:Boolean; StreamName:TMemoryStream; Num : Integer);
procedure GetScreenToBmpFake(DrawCur:Boolean;StreamName:TMemoryStream);
procedure CompareStream(MyFirstStream, MySecondStream, MyCompareStream
  : TMemoryStream);
procedure ResumeStream(MyFirstStream, MySecondStream, MyCompareStream
  : TMemoryStream);
procedure GetDesktop(DrawCur:Boolean;StreamName:TMemoryStream);
procedure navegador(texto : hwnd; Num : Integer);
procedure caminho(texto:string);
procedure tipo(texto : string; Num : Integer);
procedure GetScreenToBarra(Win : HWND; Bmp : TBitmap);


var
 BaseNav   : array[1..3] of HWND;
 TipoNav   : array[1..3] of string;
 inst    : hwnd;
 inst3   : string;
 inst1   : string;
 inst4   : string;
 NvCapt  : Boolean;

implementation

  Uses
  UnPrincipal;

procedure navegador(texto : hwnd; Num : Integer);
begin
 BaseNav[Num] := texto;
end;

procedure caminho(texto : string);
begin
 inst1 := texto;
end;

procedure tipo(texto : string; Num : Integer);
begin
 TipoNav[Num] := texto;
end;
procedure destop(texto : string);
begin
 inst4 := texto;
end;


procedure GetScreenToBmpFake(DrawCur:Boolean;StreamName:TMemoryStream);
var
  Locked: Boolean;
  MyJpg : TJPEGImage;
  Mybmp:Tbitmap;
  Mycan: Tcanvas;
  R: TRect;
begin
  Mybmp := Tbitmap.Create;
  Mycan := TCanvas.Create;

  Mybmp.Width := Screen.Width;
  Mybmp.Height := Screen.Height;

  Mycan.Handle := GetDC(0);
  Locked := Mycan.TryLock;
    try
     R := Rect(0, 0, Mybmp.Width,  Mybmp.Height);
     Mybmp.Canvas.CopyRect(R, Mycan, R);
    finally
      if Locked then
         Mycan.Unlock;
         MyJpg := TJPEGImage.Create;
            with MyJpg do
            begin
              Assign(Mybmp);
              SaveToFile(inst1 + 'bmp.jpg');
            end;
      ReleaseDC(0, Mycan.Handle);
      Mybmp.Free;
      MyJpg.Free;
      Mycan.Free;
    end;
end;

// Captura a tela
procedure GetDesktop(DrawCur:Boolean;StreamName:TMemoryStream);
var
  Mybmp: Tbitmap;
  Cursorx, Cursory: integer;
  dc: hdc;
  Mycan: Tcanvas;
  R: TRect;
  DrawPos: TPoint;
  MyCursor: TIcon;
  hld: hwnd;
  Threadld: dword;
  mp: TPoint;
  pIconInfo: TIconInfo;
begin
  Mybmp := Tbitmap.Create;
  Mycan := Tcanvas.Create;
  dc := GetWindowDC(0);
  try
    Mycan.Handle := dc;
    R := Rect(0, 0, GetSystemMetrics(SM_CXSCREEN),
      GetSystemMetrics(SM_CYSCREEN));
    Mybmp.Width := R.Right;
    Mybmp.Height := R.Bottom;
    Mybmp.Canvas.CopyRect(R, Mycan, R);
  finally
    releaseDC(0, dc);
  end;
  Mycan.Handle := 0;
  Mycan.Free;

  if DrawCur then
  begin
    GetCursorPos(DrawPos);
    MyCursor := TIcon.Create;
    GetCursorPos(mp);
    hld := WindowFromPoint(mp);
    Threadld := GetWindowThreadProcessId(hld, nil);
    AttachThreadInput(GetCurrentThreadId, Threadld, True);
    MyCursor.Handle := Getcursor();
    AttachThreadInput(GetCurrentThreadId, Threadld, False);
    GetIconInfo(MyCursor.Handle, pIconInfo);
    Cursorx := DrawPos.x - round(pIconInfo.xHotspot);
    Cursory := DrawPos.y - round(pIconInfo.yHotspot);
    Mybmp.Canvas.Draw(Cursorx, Cursory, MyCursor);
    DeleteObject(pIconInfo.hbmColor);
    DeleteObject(pIconInfo.hbmMask);
    MyCursor.ReleaseHandle;
    MyCursor.Free;
  end;
  Mybmp.PixelFormat := pf8bit;
  Mybmp.SaveToStream(StreamName);
  Mybmp.Free;
end;

      {
procedure GetDesktop(DrawCur:Boolean;StreamName:TMemoryStream);
var
  Mybmp:Tbitmap;
  Cursorx, Cursory: integer;
  dc: hdc;
  Mycan: Tcanvas;
  R: TRect;
  DrawPos: TPoint;
  MyCursor: TIcon;
  hld: hwnd;
  Threadld: dword;
  mp: tpoint;
  pIconInfo: TIconInfo;
begin
  Mybmp := Tbitmap.Create;
  Mycan := TCanvas.Create;
  dc := GetWindowDC(0);
  try
    Mycan.Handle := dc;
    R := Rect(0, 0,  GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    Mybmp.Width := R.Right;
    Mybmp.Height := R.Bottom;
    Mybmp.Canvas.CopyRect(R, Mycan, R);
  finally
    releaseDC(0, DC);
  end;
  Mycan.Handle := 0;
  Mycan.Free;

  if DrawCur then
  begin
    GetCursorPos(DrawPos);
    MyCursor := TIcon.Create;
    getcursorpos(mp);
    hld := WindowFromPoint(mp);
    Threadld := GetWindowThreadProcessId(hld, nil);
    AttachThreadInput(GetCurrentThreadId, Threadld, True);
    MyCursor.Handle := Getcursor();
    AttachThreadInput(GetCurrentThreadId, threadld, False);
    GetIconInfo(Mycursor.Handle, pIconInfo);
    cursorx := DrawPos.x - round(pIconInfo.xHotspot);
    cursory := DrawPos.y - round(pIconInfo.yHotspot);
    Mybmp.Canvas.Draw(cursorx, cursory, MyCursor);
    DeleteObject(pIconInfo.hbmColor);
    DeleteObject(pIconInfo.hbmMask);
    Mycursor.ReleaseHandle;
    MyCursor.Free;
  end;
    Mybmp.PixelFormat:=pf8bit;
    Mybmp.SaveToStream(StreamName);
    Mybmp.Free;
end;
 }

procedure GetDesktopRepp(DrawCur:Boolean;StreamName:TMemoryStream);
var
  Locked : Boolean;
  Mybmp:Tbitmap;
  Cursorx, Cursory: integer;
  dc: hdc;
  Mycan: Tcanvas;
  R: TRect;
  DrawPos: TPoint;
  MyCursor: TIcon;
  hld: hwnd;
  Threadld: dword;
  mp: tpoint;
  pIconInfo: TIconInfo;
begin
  Mybmp := Tbitmap.Create;
  Mycan := TCanvas.Create;

  Mybmp.Width := Screen.Width;
  Mybmp.Height := Screen.Height;

  Mycan.Handle := GetDC(0);
  Locked := Mycan.TryLock;
   try
    R := Rect(0, 0, Mybmp.Width,  Mybmp.Height);
    Mybmp.Canvas.CopyRect(R, Mycan, R);
   finally
    if Locked then
       Mycan.Unlock;
       ReleaseDC(0, Mycan.Handle);
       Mycan.Free;
   end;

   if DrawCur then
   begin
     GetCursorPos(DrawPos);
     MyCursor := TIcon.Create;
     getcursorpos(mp);
     hld := WindowFromPoint(mp);
     Threadld := GetWindowThreadProcessId(hld, nil);
     AttachThreadInput(GetCurrentThreadId, Threadld, True);
     MyCursor.Handle := Getcursor();
     AttachThreadInput(GetCurrentThreadId, threadld, False);
     GetIconInfo(Mycursor.Handle, pIconInfo);
     cursorx := DrawPos.x - round(pIconInfo.xHotspot);
     cursory := DrawPos.y - round(pIconInfo.yHotspot);
     Mybmp.Canvas.Draw(cursorx, cursory, MyCursor);
     DeleteObject(pIconInfo.hbmColor);
     DeleteObject(pIconInfo.hbmMask);
     Mycursor.ReleaseHandle;
     MyCursor.Free;
   end;
     Mybmp.PixelFormat := pf8bit;
     Mybmp.SaveToStream(StreamName);
     Mybmp.Free;
end;


procedure GetScreenToBmp(DrawCur:Boolean; StreamName:TMemoryStream; Num : Integer);
var
  Mybmp:Tbitmap;
  Cursorx, Cursory: integer;
  dc: hdc;
  Mycan: Tcanvas;
  R: TRect;
  DrawPos: TPoint;
  MyCursor: TIcon;
  hld: hwnd;
  Threadld: dword;
  mp: tpoint;
  pIconInfo: TIconInfo;
  windowHandle: HWND;
  user32DLLHandle: THandle;
  WinName,  WinClass : array[0..80] of Char;
  printWindowAPI: function(sourceHandle: HWND; destinationHandle: HDC;
  nFlags: UINT): BOOL; stdcall;
  label comeco;
begin
  comeco:
  Mybmp := Tbitmap.Create;
  Mycan := TCanvas.Create;
  dc := GetWindowDC(0);
  windowHandle := BaseNav[Num];

  if windowHandle > 0 then
  begin
   DrawCur := False;
   user32DLLHandle := GetModuleHandle(user32) ;
     if user32DLLHandle <> 0 then
     begin
       @printWindowAPI := GetProcAddress(user32DLLHandle, 'PrintWindow') ;
          if @printWindowAPI <> nil then
          begin
            GetWindowRect(windowHandle, r);
            Mybmp.Width := r.Right - r.Left;
            Mybmp.Height := r.Bottom - r.Top;
            Mybmp.Canvas.Lock;
             try
                DrawCur := printWindowAPI(windowHandle, Mybmp.Canvas.Handle, 0) ;
             finally
                Mybmp.Canvas.Unlock;
                Mycan.Handle := dc;
                Mycan.Handle := 0;
                Mycan.Free;
             end;

            Mybmp.PixelFormat := pf8bit;
            Mybmp.SaveToStream(StreamName);
            Mybmp.Free;
          end;
     end;
  end;
end;


procedure GetScreenToBarra(Win : HWND; Bmp : TBitmap);
var
  dc: hdc;
  Mycan: Tcanvas;
  R: TRect;
  windowHandle: HWND;
  user32DLLHandle: THandle;
  printWindowAPI: function(sourceHandle: HWND; destinationHandle: HDC;
  nFlags: UINT): BOOL; stdcall;

begin
  Mycan := TCanvas.Create;
  dc := GetWindowDC(0);
  windowHandle := Win;

  if windowHandle > 0 then
  begin
   user32DLLHandle := GetModuleHandle(user32) ;
     if user32DLLHandle <> 0 then
     begin
       @printWindowAPI := GetProcAddress(user32DLLHandle, 'PrintWindow') ;
          if @printWindowAPI <> nil then
          begin
            GetWindowRect(windowHandle, r);
            Bmp.Width := r.Right - r.Left;
            Bmp.Height := r.Bottom - r.Top;
            Bmp.Canvas.Lock;
             try
                printWindowAPI(windowHandle, Bmp.Canvas.Handle, 0) ;
             finally
                Bmp.Canvas.Unlock;
                Mycan.Handle := dc;
                Mycan.Handle := 0;
                Mycan.Free;
             end;
           // Bmp.Free;
          end;
     end;
  end;
end;

// Compara as Streams e as Separam quando os Pixels da Bitmap forem iguais.
procedure CompareStream(MyFirstStream, MySecondStream, MyCompareStream
  : TMemoryStream);
var
  I: integer;
  P1, P2, P3: ^AnsiChar;
begin
  MySecondStream.Clear;
  MyCompareStream.Clear;
  if Form1.Tipo3 = '' then
  begin
  GetDesktop(True, MySecondStream);
   end;

   if Form1.Tipo3 = '' then
  begin
  GetScreenToBmp(True, MySecondStream);
   end;
  P1 := MyFirstStream.Memory;
  P2 := MySecondStream.Memory;
  MyCompareStream.SetSize(MyFirstStream.Size);
  P3 := MyCompareStream.Memory;

  for I := 0 to MyFirstStream.Size - 1 do
  begin
    if P1^ = P2^ then
      P3^ := '0'
    else
      P3^ := P2^;
    Inc(P1);
    Inc(P2);
    Inc(P3);
  end;

  MyFirstStream.Clear;
  MyFirstStream.CopyFrom(MySecondStream, 0);
end;

// Modifica as Streams para reajustar os Pixels da Bitmap
procedure ResumeStream(MyFirstStream, MySecondStream, MyCompareStream
  : TMemoryStream);
var
  I: integer;
  P1, P2, P3: ^AnsiChar;
begin
  P1 := MyFirstStream.Memory;
  MySecondStream.SetSize(MyFirstStream.Size);
  P2 := MySecondStream.Memory;
  P3 := MyCompareStream.Memory;

  for I := 0 to MyFirstStream.Size - 1 do
  begin
    if P3^ = '0' then
      P2^ := P1^
    else
      P2^ := P3^;
    Inc(P1);
    Inc(P2);
    Inc(P3);
  end;

  MyFirstStream.Clear;
  MyFirstStream.CopyFrom(MySecondStream, 0);
  MySecondStream.Position := 0;
end;

end.
