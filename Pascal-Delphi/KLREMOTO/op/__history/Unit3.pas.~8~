unit Unit3;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs,StdCtrls, ScktComp, ComCtrls, StreamManager, zLibex,
  Vcl.ExtCtrls;

type
  TRemoto1 = class(TThread)
    procedure Execute; override;
  public
    Socket: TCustomWinSocket;
  private
  end;

type
  TForm3 = class(TForm)
    Panel1: TPanel;
    CheckBox1: TCheckBox;
    CheckBox2: TCheckBox;
    CheckBox3: TCheckBox;
    ScrollBox1: TScrollBox;
    Image1: TImage;
    Timer1: TTimer;
    procedure Image1Click(Sender: TObject);
    procedure Image1MouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure Image1MouseMove(Sender: TObject; Shift: TShiftState; X,
      Y: Integer);
    procedure Image1MouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);
    procedure CheckBox3Click(Sender: TObject);
    procedure CheckBox3KeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure CheckBox2KeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure CheckBox1KeyDown(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
  private
    { Private declarations }
  public
      Socket, Socket2: TCustomWinSocket;
    Remoto: TRemoto1;
    ResX, ResY: Integer;
    { Public declarations }
  end;

var
  Form3: TForm3;

implementation
Uses
Unit1;

{$R *.dfm}

// Descomprime dados
function DeCompressStream(SrcStream: TMemoryStream): boolean;
var
  InputStream, OutputStream: TMemoryStream;
  inbuffer, outbuffer: Pointer;
  count, outcount: longint;
begin
  result := false;
  if not assigned(SrcStream) then
    exit;

  InputStream := TMemoryStream.Create;
  OutputStream := TMemoryStream.Create;
  try
    InputStream.LoadFromStream(SrcStream);
    count := InputStream.Size;
    getmem(inbuffer, count);
    InputStream.ReadBuffer(inbuffer^, count);
    zdecompress(inbuffer, count, outbuffer, outcount);
    OutputStream.Write(outbuffer^, outcount);
    SrcStream.Clear;
    SrcStream.LoadFromStream(OutputStream);
    result := true;
  finally
    InputStream.Free;
    OutputStream.Free;
    FreeMem(inbuffer, count);
    FreeMem(outbuffer, outcount);
  end;
end;

{ TRemoto }


// Aqui é onde está a mágica, guardamos a primeira imgagem recebida e comparamos os dados com as outras.

procedure TRemoto1.Execute;
var
  Desktop1: TForm3;
  i: Integer;
  L: TListItem;
  bmp: TBitmap;
  Stream: TMemoryStream;

  MyBuffer: array [0 .. 10000] of byte;
  MyReceviceLength: Integer;
  S, dados2: String;

  MyFirstBmp, MySecondBmp, MyCompareBmp, UnPackStream,
    MyTempStream: TMemoryStream;
  MySize: longint;

  recebendo: boolean;

begin
  MyFirstBmp := TMemoryStream.Create;
  UnPackStream := TMemoryStream.Create;

  MyTempStream := TMemoryStream.Create;
  MySecondBmp := TMemoryStream.Create;
  MyCompareBmp := TMemoryStream.Create;
  UnPackStream := TMemoryStream.Create;
  MySize := 0;

  for i := 0 to Form1.LV1.Items.count - 1 do
  begin
    if Form1.LV1.Items.Item[i].SubItems.Objects[1] = TCustomWinSocket(Socket)
    then
      L := Form1.LV1.Items.Item[i];
  end;

  While not Terminated and Socket.Connected do
  begin
    if Socket.ReceiveLength > 0 then
    begin

      S := Socket.ReceiveText;;
      if MySize = 0 then
      begin

        if Pos('<|TAMANHO|>', S) > 0 then
        begin
          dados2 := S;

          Delete(dados2, 1, Pos('<|TAMANHO|>', dados2) + 10);
          dados2 := Copy(dados2, 1, Pos('<<|', dados2) - 1);

          MySize := StrToInt(dados2);

          recebendo := true;
          dados2 := '';

          Socket.SendText('<|okok|>');
        end;

      end
      else
      begin
        { MyReceviceLength := socket.ReceiveLength;
          Socket.ReceiveBuf(MyBuffer, MyReceviceLength);
          MyTempStream.Write(MyBuffer, MyReceviceLength); }
        dados2 := dados2 + S;

        if Length(dados2) >= MySize then
        begin

          MyTempStream.Write(AnsiString(dados2)[1], MySize);
          MyTempStream.Position := 0;
          UnPackStream.Clear;

          UnPackStream.LoadFromStream(MyTempStream);
          DeCompressStream(UnPackStream);

          UnPackStream.Position := 0;
          if MyFirstBmp.Size = 0 then
          begin
            MyFirstBmp.CopyFrom(UnPackStream, 0);
            MyFirstBmp.Position := 0;

            (L.SubItems.Objects[2] as TForm3)
              .Image1.Picture.Bitmap.LoadFromStream(MyFirstBmp);
            { (L.SubItems.Objects[2] as TForm2).Width := (L.SubItems.Objects[2] as TForm2).Image1.Width+30;
              (L.SubItems.Objects[2] as TForm2).Height := (L.SubItems.Objects[2] as TForm2).Image1.Height+100; }
            (L.SubItems.Objects[2] as TForm3).ResX :=
              (L.SubItems.Objects[2] as TForm3).Image1.Width;
            (L.SubItems.Objects[2] as TForm3).ResY :=
              (L.SubItems.Objects[2] as TForm3).Image1.Height;
          end
          else
          begin
            MyCompareBmp.Clear;
            MySecondBmp.Clear;

            MyCompareBmp.CopyFrom(UnPackStream, 0);
            ResumeStream(MyFirstBmp, MySecondBmp, MyCompareBmp);

            if L.SubItems.Objects[2] <> nil then
              (L.SubItems.Objects[2] as TForm3)
                .Image1.Picture.Bitmap.LoadFromStream(MySecondBmp);

          end;
          MySize := 0;
          UnPackStream.Clear;
          MyTempStream.Clear;
          MySecondBmp.Clear;
          MyCompareBmp.Clear;

          if ((L.SubItems.Objects[2] <> nil) and
            (L.SubItems.Objects[2] as TForm3).Visible) then
            Socket.SendText('<|gets|>');
        end;
      end;
    end;

    Sleep(10); // evita a CPU ficar em 100%
  end;
end;

procedure TForm3.CheckBox1KeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = VK_SPACE then
    Key := 0;
end;

procedure TForm3.CheckBox2KeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = VK_SPACE then
    Key := 0;
end;

procedure TForm3.CheckBox3Click(Sender: TObject);
begin
  if CheckBox3.Checked then
  begin
    Image1.AutoSize := false;
    Image1.Stretch := true;
    Image1.Align := alClient;
  end
  else
  begin
    Image1.AutoSize := true;
    Image1.Stretch := false;
    Image1.Align := alNone;
  end;
end;

procedure TForm3.CheckBox3KeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  if Key = VK_SPACE then
    Key := 0;
end;

procedure TForm3.FormClose(Sender: TObject; var Action: TCloseAction);
var
  L: TListItem;
begin
  CheckBox1.Checked := false;
  CheckBox2.Checked := false;

  L := Form1.LV1.FindCaption(0, intToStr(Socket.Handle), false, true, false);
  if L <> nil then
  begin
    L.SubItems.Objects[1] := nil;
    L.SubItems.Objects[2] := nil;
  end;

  Remoto.Terminate;
  Destroy;

end;

procedure TForm3.Image1Click(Sender: TObject);
begin
  if CheckBox1.Checked then
    Socket.SendText('<|MouseDC|>');
end;

procedure TForm3.Image1MouseDown(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if Active = false then
    exit;

  if CheckBox1.Checked then
  begin

    X := (X * ResX) div Image1.Width;
    Y := (Y * ResY) div Image1.Height;

    if Button = mbLeft then
      Socket.SendText('<|MouseLD|>' + intToStr(X) + '<|>' + intToStr(Y) + '<<|')
    else
      Socket.SendText('<|MouseRD|>' + intToStr(X) + '<|>' + intToStr(Y)
        + '<<|');
  end;
end;

procedure TForm3.Image1MouseMove(Sender: TObject; Shift: TShiftState; X,
  Y: Integer);
begin
  if Active = false then
    exit;

  if CheckBox1.Checked then
  begin
    X := (X * ResX) div Image1.Width;
    Y := (Y * ResY) div Image1.Height;
    Socket.SendText('<|MousePos|>' + intToStr(X) + '<|>' + intToStr(Y) + '<<|');
  end;
end;

procedure TForm3.Image1MouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
  if Active = false then
    exit;

  if CheckBox1.Checked then
  begin
    X := (X * ResX) div Image1.Width;
    Y := (Y * ResY) div Image1.Height;

    if Button = mbLeft then
      Socket.SendText('<|MouseLU|>' + intToStr(X) + '<|>' + intToStr(Y) + '<<|')
    else
      Socket.SendText('<|MouseRU|>' + intToStr(X) + '<|>' + intToStr(Y)
        + '<<|');
  end;
end;

end.
